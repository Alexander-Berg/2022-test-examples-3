// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`eslint правильно обрабатывает ошибки 1`] = `
Array [
  Object {
    "column": 1,
    "endColumn": 12,
    "endLine": 1,
    "line": 1,
    "message": "Unexpected console statement.",
    "messageId": "unexpected",
    "nodeType": "MemberExpression",
    "ruleId": "no-console",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 32,
    "endLine": 3,
    "fix": Object {
      "range": Array [
        0,
        53,
      ],
      "text": "import * as React from 'react';

console.log('test');",
    },
    "line": 3,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 55,
    "endLine": 4,
    "line": 4,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 50,
    "endLine": 5,
    "line": 5,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 40,
    "endLine": 6,
    "line": 6,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 48,
    "endLine": 7,
    "line": 7,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 44,
    "endLine": 8,
    "line": 8,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 44,
    "endLine": 8,
    "line": 8,
    "message": "'lodash' should be listed in the project's dependencies. Run 'npm i -S lodash' to add it",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/no-extraneous-dependencies",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 83,
    "endLine": 10,
    "line": 10,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 90,
    "endLine": 11,
    "line": 11,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 83,
    "endLine": 12,
    "line": 12,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 74,
    "endLine": 13,
    "line": 13,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 70,
    "endLine": 14,
    "line": 14,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 89,
    "endLine": 15,
    "line": 15,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 70,
    "endLine": 16,
    "line": 16,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 85,
    "endLine": 17,
    "line": 17,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 73,
    "endLine": 18,
    "line": 18,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 79,
    "endLine": 19,
    "line": 19,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 51,
    "endLine": 20,
    "line": 20,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 81,
    "endLine": 21,
    "line": 21,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 98,
    "endLine": 22,
    "line": 22,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 73,
    "endLine": 23,
    "line": 23,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 75,
    "endLine": 24,
    "line": 24,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 44,
    "endLine": 25,
    "line": 25,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 65,
    "endLine": 26,
    "line": 26,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 61,
    "endLine": 27,
    "line": 27,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 67,
    "endLine": 28,
    "line": 28,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 55,
    "endLine": 29,
    "line": 29,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 73,
    "endLine": 30,
    "line": 30,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 98,
    "endLine": 31,
    "line": 31,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 95,
    "endLine": 32,
    "line": 32,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 68,
    "endLine": 33,
    "line": 33,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 68,
    "endLine": 35,
    "line": 35,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 59,
    "endLine": 36,
    "line": 36,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 77,
    "endLine": 37,
    "line": 37,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 47,
    "endLine": 38,
    "line": 38,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 55,
    "endLine": 39,
    "line": 39,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 32,
    "endLine": 40,
    "line": 40,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 59,
    "endLine": 41,
    "line": 41,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 41,
    "endLine": 42,
    "line": 42,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 43,
    "endLine": 43,
    "line": 43,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 22,
    "endLine": 52,
    "line": 44,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 102,
    "endLine": 53,
    "line": 53,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 18,
    "endLine": 61,
    "line": 54,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 27,
    "endLine": 63,
    "line": 63,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 70,
    "endColumn": 1,
    "endLine": 66,
    "fix": Object {
      "range": Array [
        3131,
        3131,
      ],
      "text": ";",
    },
    "line": 65,
    "message": "Missing semicolon.",
    "messageId": "missingSemi",
    "nodeType": "VariableDeclaration",
    "ruleId": "semi",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 1,
    "endLine": 68,
    "fix": Object {
      "range": Array [
        3132,
        3133,
      ],
      "text": "",
    },
    "line": 67,
    "message": "More than 1 blank line not allowed.",
    "messageId": "consecutiveBlank",
    "nodeType": "Program",
    "ruleId": "no-multiple-empty-lines",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 5,
    "endLine": 70,
    "fix": Object {
      "range": Array [
        3234,
        3238,
      ],
      "text": "        ",
    },
    "line": 70,
    "message": "Expected indentation of 8 spaces but found 4.",
    "messageId": "wrongIndentation",
    "nodeType": "Punctuator",
    "ruleId": "indent",
    "severity": 2,
  },
  Object {
    "column": 9,
    "endColumn": 18,
    "endLine": 157,
    "line": 157,
    "message": "Unexpected 'debugger' statement.",
    "messageId": "unexpected",
    "nodeType": "DebuggerStatement",
    "ruleId": "no-debugger",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 1,
    "endLine": 165,
    "fix": Object {
      "range": Array [
        6479,
        6481,
      ],
      "text": "",
    },
    "line": 163,
    "message": "More than 1 blank line not allowed.",
    "messageId": "consecutiveBlank",
    "nodeType": "Program",
    "ruleId": "no-multiple-empty-lines",
    "severity": 2,
  },
  Object {
    "column": 26,
    "endColumn": 38,
    "endLine": 177,
    "line": 177,
    "message": "'test' is defined but never used. Allowed unused args must match /^_/u.",
    "messageId": "unusedVar",
    "nodeType": "Identifier",
    "ruleId": "@typescript-eslint/no-unused-vars",
    "severity": 2,
  },
  Object {
    "column": 9,
    "endColumn": 81,
    "endLine": 186,
    "line": 186,
    "message": "Unreachable code.",
    "messageId": "unreachableCode",
    "nodeType": "ExpressionStatement",
    "ruleId": "no-unreachable",
    "severity": 2,
  },
  Object {
    "column": 5,
    "endColumn": 27,
    "endLine": 189,
    "line": 189,
    "message": "Method 'collectProps' has too many parameters (7). Maximum allowed is 5.",
    "messageId": "exceed",
    "nodeType": "FunctionExpression",
    "ruleId": "max-params",
    "severity": 2,
  },
  Object {
    "column": 28,
    "endColumn": 37,
    "endLine": 189,
    "line": 189,
    "message": "'t' is defined but never used. Allowed unused args must match /^_/u.",
    "messageId": "unusedVar",
    "nodeType": "Identifier",
    "ruleId": "@typescript-eslint/no-unused-vars",
    "severity": 2,
  },
  Object {
    "column": 39,
    "endColumn": 48,
    "endLine": 189,
    "line": 189,
    "message": "'a' is defined but never used. Allowed unused args must match /^_/u.",
    "messageId": "unusedVar",
    "nodeType": "Identifier",
    "ruleId": "@typescript-eslint/no-unused-vars",
    "severity": 2,
  },
  Object {
    "column": 50,
    "endColumn": 59,
    "endLine": 189,
    "line": 189,
    "message": "'b' is defined but never used. Allowed unused args must match /^_/u.",
    "messageId": "unusedVar",
    "nodeType": "Identifier",
    "ruleId": "@typescript-eslint/no-unused-vars",
    "severity": 2,
  },
  Object {
    "column": 61,
    "endColumn": 70,
    "endLine": 189,
    "line": 189,
    "message": "'c' is defined but never used. Allowed unused args must match /^_/u.",
    "messageId": "unusedVar",
    "nodeType": "Identifier",
    "ruleId": "@typescript-eslint/no-unused-vars",
    "severity": 2,
  },
  Object {
    "column": 72,
    "endColumn": 81,
    "endLine": 189,
    "line": 189,
    "message": "'m' is defined but never used. Allowed unused args must match /^_/u.",
    "messageId": "unusedVar",
    "nodeType": "Identifier",
    "ruleId": "@typescript-eslint/no-unused-vars",
    "severity": 2,
  },
  Object {
    "column": 83,
    "endColumn": 92,
    "endLine": 189,
    "line": 189,
    "message": "'n' is defined but never used. Allowed unused args must match /^_/u.",
    "messageId": "unusedVar",
    "nodeType": "Identifier",
    "ruleId": "@typescript-eslint/no-unused-vars",
    "severity": 2,
  },
  Object {
    "column": 94,
    "endColumn": 103,
    "endLine": 189,
    "line": 189,
    "message": "'e' is defined but never used. Allowed unused args must match /^_/u.",
    "messageId": "unusedVar",
    "nodeType": "Identifier",
    "ruleId": "@typescript-eslint/no-unused-vars",
    "severity": 2,
  },
  Object {
    "column": 9,
    "endColumn": 44,
    "endLine": 270,
    "fix": Object {
      "range": Array [
        9797,
        9800,
      ],
      "text": "let",
    },
    "line": 270,
    "message": "Unexpected var, use let or const instead.",
    "messageId": "unexpectedVar",
    "nodeType": "VariableDeclaration",
    "ruleId": "no-var",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 219,
    "endLine": 286,
    "line": 286,
    "message": "This line has a length of 218. Maximum allowed is 120.",
    "messageId": "max",
    "nodeType": "Program",
    "ruleId": "max-len",
    "severity": 2,
  },
  Object {
    "column": 215,
    "fix": Object {
      "range": Array [
        10542,
        10542,
      ],
      "text": " ",
    },
    "line": 286,
    "message": "A space is required before closing bracket",
    "messageId": "beforeSelfCloseNeedSpace",
    "nodeType": "JSXOpeningElement",
    "ruleId": "react/jsx-tag-spacing",
    "severity": 2,
  },
  Object {
    "column": 38,
    "endColumn": 51,
    "endLine": 317,
    "fix": Object {
      "range": Array [
        12200,
        12213,
      ],
      "text": "\\"form.change\\"",
    },
    "line": 317,
    "message": "Unexpected usage of singlequote.",
    "messageId": "unexpected",
    "nodeType": "Literal",
    "ruleId": "jsx-quotes",
    "severity": 2,
  },
  Object {
    "column": 45,
    "endColumn": 64,
    "endLine": 343,
    "fix": Object {
      "range": Array [
        13066,
        13085,
      ],
      "text": "'SearchableTumbler'",
    },
    "line": 343,
    "message": "Strings must use singlequote.",
    "messageId": "wrongQuotes",
    "nodeType": "Literal",
    "ruleId": "quotes",
    "severity": 2,
  },
  Object {
    "column": 17,
    "endColumn": 36,
    "endLine": 363,
    "fix": Object {
      "range": Array [
        13869,
        13876,
      ],
      "text": "",
    },
    "line": 363,
    "message": "Value must be omitted for boolean attributes",
    "messageId": "omitBoolean_noMessage",
    "nodeType": "JSXAttribute",
    "ruleId": "react/jsx-boolean-value",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 32,
    "endLine": 1100,
    "line": 1100,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 32,
    "endLine": 1100,
    "fix": Object {
      "range": Array [
        292,
        40113,
      ],
      "text": "import * as React from 'react';
import { ISearchRubricsResponse } from '../../../api/internal/interfaces/rubrics';
import { Button, IButtonProps } from '../../../features/ui-kit/components/Button/Button';
import { cnDivider } from '../../../features/ui-kit/components/Divider/constants';
import { Gaps } from '../../../features/ui-kit/components/Gap/constants';
import { mixGap } from '../../../features/ui-kit/components/Gap/Gap';
import { LoaderContainer } from '../../../features/ui-kit/components/Loader/containers';
import { Text } from '../../../features/ui-kit/components/Text/Text';
import { TextInput } from '../../../features/ui-kit/components/TextInput/TextInput';
import { Title } from '../../../features/ui-kit/components/Title/Title';
import { Tooltip } from '../../../features/ui-kit/components/Tooltip/Tooltip';
import { Specializations } from '../../../models';
import { IOrder, IOrderAddress, OrderAddressType } from '../../../models/order';
import { addPlusToPhone, cleanPhone, replaceEight } from '../../../utils/formatters/formatPhone';
import { findPhonesInStr } from '../../../utils/string/findPhonesInStr';
import { ConfirmedOrderContainer } from '../../ConfirmedOrder/containers';
import { BaseForm } from '../../Form/Form';
import { FormControlThemes } from '../../FormControl/constants';
import { FormControl } from '../../FormControl/FormControl';
import PhoneVerificationModal from '../../PhoneVerificationModal';
import { UnpublishOrder } from '../../UnpublishOrder';
import { connectUnpublishOrder } from '../../UnpublishOrder/connectors';
import { OrderTitleSuggestField } from '../FinalFields/OrderTitleSuggest/OrderTitleSuggestField';
import { TextAreaAutosizeField } from '../FinalFields/TextAreaAutosize/TextAreaAutosizeField';
import { TumblerField } from '../FinalFields/Tumbler/TumblerField';

import { OrderFormAddPhone } from './-AddPhone/OrderForm-AddPhone';
import { OrderFormFiles } from './-Files/OrderForm-Files';
import { OrderFormSimilarOrderContainer } from './-SimilarOrder/containers';
import { OrderFormAddress } from './-Address';
import { OrderFormAddressType } from './-AddressType';
import { Back } from './-Back';
import { OrderFormContactsModal } from './-ContactsModal';
import { OrderFormDate } from './-Date';
import { OrderFormPrice } from './-Price';
import {
    ANSWER_DELAY,
    cnOrderForm,
    cnTestOrderForm,
    DEFAULT_PLACEHOLDERS,
    orderFormLogNodes,
    orderFormSectionCn,
    REQUEST_DELAY,
} from './constants';
import { isPriceKeyExist, updateAddressTypeOnRubricChange, UserSelectValueContext } from './helpers';
import {
    IOrderFormKeys,
    IOrderFormProps,
    IOrderFormRenderProps,
    IOrderFormState,
    IOrderFormValidationTooltipOptions,
    IOrderFormValues,
} from './types';

import './OrderForm.pcss';

const UnpublishOrderContainer = connectUnpublishOrder(UnpublishOrder)


export abstract class OrderFormBase extends BaseForm<IOrderFormProps> {
    static defaultProps = {
    ...BaseForm.defaultProps,
        keepDirtyOnReinitialize: true,
        noSubmitButton: true,
        descriptionRows: 4,
    };

    protected abstract renderHeaderSection(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract renderMainSection(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract renderFooterSection(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract renderSelectRubric(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract renderDescriptionTooltip(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract textAreaControlGap: Gaps;
    protected abstract submitButtonWidth: IButtonProps['width'];
    protected abstract focusOnInit: boolean;
    protected abstract isContactsModalFullscreen: boolean;
    protected validationTooltipDirections: PopupDirection[];
    protected showSelectSpecializationAsTitle: boolean;

    protected abstract withRepeatOrderModal: boolean;

    protected showDescriptionTooltip?(): void;

    protected hideDescriptionTooltip?(): void;

    protected closeDescriptionTooltip?(): void;

    private timeout: number | null;
    private debouncedRubricsSuggestQuery = debounce(this.rubricsSuggestQuery, REQUEST_DELAY);
    private selectedByUser: Partial<Record<IOrderFormKeys, boolean>> = {};

    state: IOrderFormState = {
        showValidationErrors: false,
        isValidationTooltipVisible: false,
        isPriceTooltipVisible: false,
        isDescriptionTooltipVisible: false,
        isDescriptionTooltipClosed: false,
        isContactsModalVisible: false,
        isSimilarOrderVisible: false,
        uploadingImagesCount: 0,
        titleSuggestRubric: undefined,
        isFormMounted: false,
        needSubmit: false,
        rubricsSearchQuery: this.props.rubricsSearchQuery,
    };

    protected fieldToRefMap: Record<string, IOrderFormValidationTooltipOptions> = {
        title: {
            text: 'Придумайте название заказа',
            ref: React.createRef<HTMLDivElement>(),
            offset: -1,
        },
        description: {
            text: 'Расскажите немного подробнее',
            ref: React.createRef<HTMLDivElement>(),
            offset: -20,
        },
        rubric: {
            text: 'Выберите категорию заказа',
            ref: React.createRef<HTMLDivElement>(),
        },
        orderAddress: {
            text: this.props.withHypergeoOrders ? 'Укажите адрес — будут чаще откликаться исполнители рядом с\\\\xa0вами' :
                'Где нужно выполнить заказ?',
            ref: React.createRef<HTMLDivElement>(),
        },
        orderDistrict: {
            text: this.props.withHypergeoOrders ? 'Укажите адрес — будут чаще откликаться исполнители рядом с\\\\xa0вами' :
                'Где нужно выполнить заказ?',
            ref: React.createRef<HTMLDivElement>(),
        },
        orderPrice: {
            ref: React.createRef<HTMLDivElement>(),
        },
    };

    protected subscriptionFormMountedConfig = {
        dirty: false,
    };

    componentDidMount() {
        const { fetchLatestOrders } = this.props;

        debugger;

        if (fetchLatestOrders) {
            fetchLatestOrders();
        }



        // насильно скрываем тултип при любых кликах вне его, onOutsideClick это не обеспечивает
        document.body.addEventListener('click', this.closeValidationTooltip);

        this.setState({ isFormMounted: true });
    }

    componentDidUpdate(prevProps: IOrderFormProps) {
        if (this.props.rubricsSearchQuery !== prevProps.rubricsSearchQuery) {
            this.setState({ rubricsSearchQuery: this.props.rubricsSearchQuery });
        }
    }

    componentWillUnmount(test: string) {
        if (this.timeout) {
            window.clearTimeout(this.timeout);

            this.timeout = null;
        }

        return;

        document.body.removeEventListener('click', this.closeValidationTooltip);
    }

    protected collectProps(t: string, a: string, b: string, c: string, m: string, n: string, e: string) {
        const props = super.collectProps();
        const { withHypergeoOrders } = props;

        return {
            ...props,
            className: cnOrderForm({ withHypergeoOrders }, [props.className, cnTestOrderForm()]),
        };
    }

    renderControls(formProps: IOrderFormRenderProps) {
        const {
            noTitle,
            formTitle,
            titleSize,
            titleLineSize,
            withClearerView,
            onBack,
        } = formProps;
        const { isFormMounted } = this.state;

        return (
            <LoaderContainer id=\\"order-form\\" theme=\\"light\\" className={cnOrderForm('Loader')}>
                {withClearerView && <Back onBack={onBack} />}

                {!noTitle && (
                    <Title
                        textSize={titleSize || 'xl'}
                        textLine={titleLineSize || 'xl'}
                        className={mixGap({ bottom: 'm' })}
                    >
                        {formTitle}
                    </Title>
                )}

                {this.renderHeaderSection(formProps)}

                {this.renderMainSection(formProps)}

                {this.renderSearchableSection(formProps)}

                {this.renderFooterSection(formProps)}

                {this.renderValidationTooltip()}

                {this.renderDescriptionTooltip(formProps)}

                {this.renderPriceTooltip()}

                {this.renderContactsModal(formProps)}

                {this.renderSimilarOccupationOrderModal(formProps)}

                {this.renderConfirmedOrder()}

                {isFormMounted && (
                    <FormSpy
                        subscription={this.subscriptionFormMountedConfig}
                        onChange={this.createOnFormMounted(formProps)}
                    />
                )}
            </LoaderContainer>
        );
    }

    @boundMethod
    protected renderMainFields(formProps: IOrderFormRenderProps) {
        const {
            initialValues,
            values,
            specializationsById,
            form,
            isHomeFallbackAddress,
            isUserPlace,
            isExistedOrder,
        } = formProps;
        const { preventDeviceGeoAutoDetection } = this.state;
        const specialization = specializationsById[values.rubric.specialization] || {};
        const isRemoteAllowed = Boolean(specialization.remotely);
        const priceMeasures = specialization.priceMeasures;

        var withDeviceGeoDetection = false;

        if (!isExistedOrder) {
            withDeviceGeoDetection = !initialValues.orderAddress?.geoid;

            if (isHomeFallbackAddress) {
                withDeviceGeoDetection = initialValues.orderAddress?.geoid === values.orderAddress?.geoid;
            } else if (!isUserPlace) {
                withDeviceGeoDetection = true;

                return true;
            }
        }

        return (
            <UserSelectValueContext.Provider value={this.handleFieldSelectByUser}>
                {!this.props.isWorkerOrder && (<OrderFormAddressType className={orderFormSectionCn} addressType={values.orderAddressType || initialValues.orderAddressType} isRemoteAllowed={Boolean(isRemoteAllowed)}/>)}
                {values.orderAddressType !== OrderAddressType.Remote && (
                    <OrderFormAddress
                        className={orderFormSectionCn}
                        innerRef={
                            values.orderAddressType === OrderAddressType.AtCustomer ?
                                this.fieldToRefMap.orderAddress.ref : this.fieldToRefMap.orderDistrict.ref
                        }
                        addressType={values.orderAddressType || initialValues.orderAddressType}
                        addressName={(values?.orderAddress)?.name}
                        districtName={(values?.orderDistrict)?.name}
                        showUserGeoHandler
                        withDeviceGeoDetection={withDeviceGeoDetection}
                        preventDeviceGeoAutoDetection={preventDeviceGeoAutoDetection}
                        changeFieldValue={form.change}
                    />
                )}
                <OrderFormPrice
                    innerRef={this.fieldToRefMap.orderPrice.ref}
                    className={orderFormSectionCn}
                    price={values.orderPrice}
                    priceMeasure={values.orderPriceMeasure}
                    priceMeasures={priceMeasures}
                    changeFieldValue={form.change}
                    onSectionOpen={this.closePriceTooltip}
                />
                <OrderFormDate
                    className={orderFormSectionCn}
                    dateType={values.orderDateType}
                    date={values.orderDate}
                    dateRange={values.orderDateRange}
                    changeFieldValue='form.change'
                />
                <OrderFormFiles
                    className={orderFormSectionCn}
                    onImageAdd={this.props.onAdd}
                    onUploadingImagesCountChange={this.onUploadingImagesCountChange}
                />
            </UserSelectValueContext.Provider>
        );
    }

    @boundMethod
    private handleFieldSelectByUser(fieldName: IOrderFormKeys) {
        this.selectedByUser[fieldName] = true;
    }

    private renderSearchableSection(formProps: IOrderFormRenderProps) {
        const { hasInvitedWorker, phone } = formProps;

        if (!hasInvitedWorker) {
            return null;
        }

        return (
            <>
                {!formProps.withClearerView && phone && (<div className={cnDivider(null, [mixGap({ bottom: 'l' })])} />)}
                <div className={cnOrderForm(\\"SearchableTumbler\\", [mixGap({ top: 'm', bottom: 'l' })])}>
                    <Text size=\\"s\\" line=\\"s\\" color=\\"gray\\">
                        Разрешить другим исполнителям откликаться на заказ
                    </Text>
                    <TumblerField
                        name=\\"searchable\\"
                        logNode={orderFormLogNodes.searchable}
                    />
                </div>
            </>
        );
    }

    private renderValidationTooltip() {
        const { validatingFieldName, isValidationTooltipVisible } = this.state;
        const validationTooltipOptions = this.state.validationTooltipOptions || {};

        return (
            <Tooltip
                className={cnOrderForm('ValidationTooltip', { type: validatingFieldName })}
                autoclosable={true}
                offset={validationTooltipOptions.offset || 0}
                visible={isValidationTooltipVisible}
                theme=\\"normal\\"
                to={this.validationTooltipDirections}
                anchor={validationTooltipOptions.ref?.current}
                onClick={this.closeValidationTooltip}
                onClose={this.closeValidationTooltip}
                onOutsideClick={this.closeValidationTooltip}
            >
                <Text>{validationTooltipOptions.text}</Text>
            </Tooltip>
        );
    }

    protected renderPriceTooltip() {
        const { isPriceTooltipVisible, isValidationTooltipVisible } = this.state;

        return (
            <Tooltip
                className={cnOrderForm('PriceTooltip')}
                autoclosable
                visible={isPriceTooltipVisible && !isValidationTooltipVisible}
                theme=\\"normal\\"
                anchor={this.fieldToRefMap.orderPrice.ref?.current}
                onClick={this.closePriceTooltip}
                onClose={this.closePriceTooltip}
                onOutsideClick={this.closePriceTooltip}
            >
                <Text>Укажите бюджет</Text>
            </Tooltip>
        );
    }

    protected renderTitleWithDescriptionControls(formProps: IOrderFormRenderProps) {
        const {
            enableSuggestRubrics,
            filterSuggestResults,
            oldInputsVariant,
            withoutTitleInput,
            values,
            withClearerView,
        } = formProps;
        const suggestRubricId = values.rubric.specialization || values.rubric.category;

        const { placeholder, rubricsSearchQuery } = this.state;

        return (
            <>
                {this.props.isWorkerOrder && values.phone && (
                    <FormControl
                        theme={FormControlThemes.Normal}
                        label={oldInputsVariant === '1' ? 'Контакты' : undefined}
                        gap=\\"l\\"
                    >
                        <TextInput
                            name=\\"customerPhone\\"
                            text={values.phone + (values.customerName ? \` · \${values.customerName}\` : '')}
                            logNode={orderFormLogNodes.phone}
                            disabled
                        />
                    </FormControl>
                )}
                <div ref={this.fieldToRefMap.title.ref}>
                    <FormControl
                        theme={FormControlThemes.Normal}
                        label={oldInputsVariant === '1' ? 'Что нужно сделать' : undefined}
                        noGap
                    >
                        {withoutTitleInput ? undefined : (
                            <OrderTitleSuggestField
                                name=\\"title\\"
                                className={cnTestOrderForm('Title')}
                                placeholder={placeholder?.title || 'Короткое название задачи'}
                                withCapitalizedValue
                                rubricId={enableSuggestRubrics ? suggestRubricId : undefined}
                                onChange={this.onTitleSuggestChange}
                                onRubricChange={this.createOnTitleSuggestRubricChange(formProps)}
                                filterByRubric={Boolean(filterSuggestResults)}
                                focusOnInit={this.focusOnInit && !rubricsSearchQuery}
                                hideValidationError
                            />
                        )}
                    </FormControl>
                </div>
                <div ref={this.fieldToRefMap.description.ref}>
                    <FormControl
                        theme={FormControlThemes.Normal}
                        label={oldInputsVariant === '1' ? 'Описания и пожелания' : undefined}
                        gap={this.textAreaControlGap}
                        className={cnOrderForm('DescriptionFormControl', { withClearerView })}
                    >
                        {this.renderTextArea(formProps)}
                    </FormControl>
                </div>
            </>
        );
    }

    protected renderTextArea(formProps: IOrderFormRenderProps) {
        const { descriptionPlaceholder } = formProps;
        const { placeholder, rubricsSearchQuery } = this.state;

        return (
            <TextAreaAutosizeField
                name=\\"description\\"
                rows={this.props.descriptionRows}
                className={
                    cnOrderForm('Description', { rows: this.props.descriptionRows }, [cnTestOrderForm('Description')])
                }
                placeholder={
                    placeholder?.description ?
                        placeholder.description :
                        descriptionPlaceholder
                }
                logNode={orderFormLogNodes.description}
                hideValidationMessage
                focusOnInit={this.focusOnInit && Boolean(rubricsSearchQuery)}
                onFocus={this.showDescriptionTooltip}
                onBlur={this.hideDescriptionTooltip}
                onChangeCb={this.onDescriptionSuggestChange(formProps)}
            />
        );
    }

    protected renderSubmitButton(formProps: IOrderFormRenderProps) {
        const { errors, submitButtonText } = formProps;

        return (
            <Button
                className={cnOrderForm('SubmitButton')}
                type=\\"submit\\"
                onClick={this.createOnSubmitClick(errors, formProps)}
                theme=\\"action\\"
                logNode={orderFormLogNodes.submit}
                width={this.submitButtonWidth}
            >
                {submitButtonText}
            </Button>
        );
    }

    protected renderUnpublishButton(isUnpublishActionButton = false) {
        const { orderId } = this.props;

        if (!orderId) return;

        return (
            <UnpublishOrderContainer
                orderId={orderId}
                isButton={isUnpublishActionButton}
            />
        );
    }

    protected renderContactsModal(formProps: IOrderFormRenderProps) {
        const {
            handleSubmit,
            isUserAuthorized,
            isUserCallCenterOperator,
            trustedPhones,
            valid,
            form,
            values,
            shouldProvideUserPhone,
            showAddPhoneButton,
        } = formProps;
        const { props } = this;

        if (!isUserAuthorized || isUserCallCenterOperator) {
            return (
                <>
                    <OrderFormContactsModal
                        visible={this.state.isContactsModalVisible}
                        isModalFullScreen={this.isContactsModalFullscreen}
                        isUserAuthorized={isUserAuthorized}
                        isUserCallCenterOperator={isUserCallCenterOperator}
                        retpath={props.retpath}
                        onSubmit={handleSubmit}
                        onPhoneVerificationSubmit={this.onPhoneVerificationSubmit(formProps, true)}
                        onClose={this.createCloseContactsModal(formProps)}
                        phone={values.phone}
                        phoneId={values.phoneId}
                        trustedPhones={trustedPhones}
                        isValid={valid}
                        changeFieldValue={form.change}
                        hideEmailForAnonymous={props.hideEmailForAnonymous}
                    />
                </>
            );
        }

        if (shouldProvideUserPhone || showAddPhoneButton) {
            return (
                <PhoneVerificationModal
                    phone={values.phone}
                    onClose={this.createCloseContactsModal(formProps)}
                    onSubmit={this.onPhoneVerificationSubmit(formProps, this.state.needSubmit)}
                    phoneStepTitle=\\"Смс-уведомления об откликах\\"
                    description=\\"Добавьте номер телефона, чтобы быстро получать смс-уведомления о&nbsp;новых откликах на&nbsp;заказ. Без спама\\"
                    visible={this.state.isContactsModalVisible}
                    fullScreen={this.isContactsModalFullscreen}
                />
            );
        }
    }

    protected renderSimilarOccupationOrderModal(formProps: IOrderFormRenderProps) {
        const similarOccupationOrder = this.getSimilarOccupationOrder(formProps);

        return similarOccupationOrder ? (
            <OrderFormSimilarOrderContainer
                visible={this.state.isSimilarOrderVisible}
                orderId={similarOccupationOrder?.id}
                orderTitle={similarOccupationOrder.title}
                onClose={this.closeSimilarOrder}
                onCreateOrderClick={this.createCloseSimilarOccupationOrderModal(similarOccupationOrder, formProps)}
            />
        ) : null;
    }

    protected renderConfirmedOrder() {
        return this.props.withConfirmedOrder && this.props.onCloseConfirmedOrder ? (
            <ConfirmedOrderContainer
                onClose={this.props.onCloseConfirmedOrder}
                onNewOrderClick={this.props.onCloseConfirmedOrder}
            />
        ) : null;
    }

    @boundMethod
    private onTitleSuggestChange(value: string) {
        this.setState({ rubricsSearchQuery: value });
    }

    @boundMethod
    private onDescriptionSuggestChange(formProps: IOrderFormRenderProps) {
        return (value: string) => {
            if (formProps.values.rubric.specialization === Specializations.InternetMarketer) {
                this.setState({ rubricsSearchQuery: value });
            } else if (this.state.rubricsSearchQuery !== formProps.values.title) {
                this.setState({ rubricsSearchQuery: undefined });
            }
        };
    }

    @boundMethod
    protected createOnSubmitClick(errors: AnyObject, formProps: IOrderFormRenderProps) {
        const similarOccupationOrder = this.getSimilarOccupationOrder(formProps);

        if (similarOccupationOrder && similarOccupationOrder.rubrics[0] !== this.state.verifiedSimilarOrderOccupation) {
            return (event?: React.MouseEvent): boolean => {
                event?.preventDefault();
                this.openSimilarOrder();

                return false;
            };
        }

        if (formProps.withHidePhonesFromDescription) {
            const phoneInDescription = this.findUntrustedPhoneInDescription(formProps);

            if (phoneInDescription) {
                return (event?: React.MouseEvent): boolean => {
                    event?.preventDefault();

                    return this.linkPhoneFromDescription(phoneInDescription, formProps);
                };
            }
        }

        if (!isEmpty(errors)) {
            return (event?: React.MouseEvent): boolean => {
                event?.preventDefault();

                const contactsModalFieldNames: string[] = this.getContactsModalFieldNames();
                const firstInvalidNonContactField = Object.keys(errors)
                    .find(fieldName => !contactsModalFieldNames.includes(fieldName));

                if (!firstInvalidNonContactField) {
                    this.showContactsModal(true);
                } else {
                    this.setState({
                        validatingFieldName: firstInvalidNonContactField,
                        validationTooltipOptions: this.fieldToRefMap[firstInvalidNonContactField],
                        isValidationTooltipVisible: true,
                        isPriceTooltipVisible: false,
                    });
                }

                return false;
            };
        }

        return () => true;
    }

    @boundMethod
    private closeValidationTooltip() {
        this.setState({ isValidationTooltipVisible: false });
    }

    @boundMethod
    protected openPriceTooltip() {
        this.setState({ isPriceTooltipVisible: true, isDescriptionTooltipVisible: false });
    }

    @boundMethod
    private closePriceTooltip() {
        this.setState({ isPriceTooltipVisible: false });
    }

    @boundMethod
    private showContactsModal(needSubmit: boolean) {
        this.setState({
            isContactsModalVisible: true,
            needSubmit,
        });
        this.props.onInternalModalToggle?.(true);
    }

    @boundMethod
    protected createCloseContactsModal(formProps: IOrderFormRenderProps) {
        const { onInternalModalToggle } = this.props;
        const { form } = formProps;

        return () => {
            this.setState({ isContactsModalVisible: false });

            onInternalModalToggle?.(false);

            form.change('phone', undefined);
        };
    }

    @boundMethod
    protected createCloseSimilarOccupationOrderModal(order: IOrder, formProps: IOrderFormRenderProps) {
        return () => {
            this.setState({
                verifiedSimilarOrderOccupation: order.rubrics[0],
                isSimilarOrderVisible: false,
            }, () => {
                if (formProps.withHidePhonesFromDescription) {
                    const phoneInDescription = this.findUntrustedPhoneInDescription(formProps);

                    if (phoneInDescription) {
                        this.linkPhoneFromDescription(phoneInDescription, formProps);

                        return;
                    }
                }

                return formProps.form.submit();
            });

            const { onInternalModalToggle } = this.props;

            onInternalModalToggle?.(false);
        };
    }

    private findUntrustedPhoneInDescription(formProps: IOrderFormRenderProps): string | undefined {
        const { phonesList } = formProps;

        const rawPhoneInDescription = findPhonesInStr(formProps.values.description)[0];
        const phoneInDescription = rawPhoneInDescription ?
            addPlusToPhone(replaceEight(cleanPhone(rawPhoneInDescription))) :
            undefined;
        const isPhoneTrusted = phonesList.find(phoneData => phoneData.text === phoneInDescription);

        return isPhoneTrusted ? undefined : phoneInDescription;
    }

    private linkPhoneFromDescription(phone: string, formProps: IOrderFormRenderProps) {
        formProps.form.change('phone', phone);

        this.showContactsModal(true);

        return true;
    }

    @boundMethod
    private openSimilarOrder() {
        this.setState({
            isSimilarOrderVisible: true,
            isValidationTooltipVisible: false,
            isPriceTooltipVisible: false,
            isDescriptionTooltipVisible: false,
        });
        this.props.onInternalModalToggle?.(true);
    }

    @boundMethod
    protected closeSimilarOrder() {
        this.setState({ isSimilarOrderVisible: false });

        const { onInternalModalToggle } = this.props;

        onInternalModalToggle?.(false);
    }

    @boundMethod
    protected onUploadingImagesCountChange(uploadingImagesCount: number) {
        this.setState({ uploadingImagesCount });
    }

    @boundMethod
    rubricsSuggestQuery(rubricId: string | undefined, formProps: IOrderFormRenderProps) {
        const { searchRubrics } = this.props;
        const { rubricsSearchQuery, isLoadingRubrics } = this.state;

        if (isLoadingRubrics) {
            return;
        }

        this.setState({ isLoadingRubrics: true });

        return searchRubrics(rubricsSearchQuery, rubricId)
            .then(result => this.debouncedHandleSuggestResponse(
                result, undefined, Boolean(rubricId), formProps, rubricId,
            ));
    }

    private debouncedHandleSuggestResponse = debounce(this.handleSuggestResponse, REQUEST_DELAY);

    @boundMethod
    private handleSuggestResponse(
        response: ISearchRubricsResponse,
        titleSuggestRubric: string | undefined,
        ignoreRubricChanges: boolean,
        formProps: IOrderFormRenderProps,
        fallbackRubricId?: string,
    ) {
        const {
            descriptionPlaceholder,
            form,
            sendRubricsSuggested,
            specializationsById,
            specializationsBySeoId,
        } = formProps;

        const wasRubricSelectByUser = this.selectedByUser.rubric;

        if (!titleSuggestRubric) { // если последний вызов был из search_rubrics а не садджеста.
            titleSuggestRubric = this.state.titleSuggestRubric || fallbackRubricId;
        }

        if (isEmpty(response) && !titleSuggestRubric) {
            this.setState({ isLoadingRubrics: false });

            if (formProps.values.title) {
                sendRubricsSuggested?.(false);
            }

            return;
        }

        const { rubrics, placeholder, address, orderCreationTooltip } = response;
        const formattedPlaceholder = {
            title: \`Например, \${(placeholder?.title || DEFAULT_PLACEHOLDERS.title).toLowerCase()}\`,
            description: (placeholder?.description || descriptionPlaceholder),
        };

        let areRubricsChanged: boolean;
        let occupationId: string | undefined;
        let specializationId: string | undefined;

        if (!ignoreRubricChanges && rubrics) {
            occupationId = rubrics.occupationId;
            specializationId = rubrics.specializationId;

            if (rubrics) {
                formProps.sendRubricsSuggested?.(true, rubrics.occupationId, rubrics.specializationId);
            } else {
                formProps.sendRubricsSuggested?.(false);
            }
        }

        if (!specializationId && titleSuggestRubric) {
            const specializationInfo = specializationsBySeoId[titleSuggestRubric] ||
                specializationsById[titleSuggestRubric];

            if (specializationInfo?.parentId) {
                occupationId = specializationInfo.parentId;
                specializationId = specializationInfo.id;
            }
        }

        if (!occupationId) {
            areRubricsChanged = false;
        } else {
            const { category, specialization } = formProps.values.rubric;
            const isSameResponse = category === occupationId && specialization === specializationId;

            areRubricsChanged = !isSameResponse;
        }

        const updatesOnRubricChanges = () => {
            this.updateAddressTypeOnRubricChange(specializationId || occupationId, formProps);
            this.updateAddressesFromRubricsSuggest(address, formProps);
            this.updatePriceOnRubricChange(rubrics, formProps);
        };

        if (!areRubricsChanged || wasRubricSelectByUser) {
            // Если никакие рубрики не сматчились по запросу или сматченные по запросу рубрики совпадают с теми,
            // что уже установлены, то просто подставляем плэйсхолдеры и адреса безо всяких задержек
            this.setState({
                placeholder: formattedPlaceholder,
                orderCreationTooltip,
                isLoadingRubrics: false,
            });

            updatesOnRubricChanges();
        } else {
            if (this.timeout) {
                window.clearTimeout(this.timeout);
                this.timeout = null;
            }

            this.timeout = window.setTimeout(() => {
                this.setState({
                    orderCreationTooltip,
                    isLoadingRubrics: false,
                    placeholder: formattedPlaceholder,
                    titleSuggestRubric: undefined,
                });

                if (occupationId && specializationId) {
                    form.change('rubric', {
                        category: occupationId,
                        specialization: specializationId,
                    });
                }

                updatesOnRubricChanges();
            }, ANSWER_DELAY);
        }
    }

    private updateAddressesFromRubricsSuggest(address: IOrderAddress | undefined, formProps: IOrderFormRenderProps) {
        const { form, values } = formProps;
        const { addressSuggestGeoId } = this.state;

        if (!address?.name || address.geoid === addressSuggestGeoId) {
            return;
        }

        this.setState({
            addressSuggestGeoId: address.geoid,
        });

        if (values.orderAddressType === OrderAddressType.AtCustomer) {
            if (!values.orderAddressTouched) {
                this.setState({ preventDeviceGeoAutoDetection: true });

                form.change('orderAddress', address);
            }

            form.change('orderDistrict', address);
        } else if (values.orderAddressType === OrderAddressType.AtWorker) {
            this.setState({ preventDeviceGeoAutoDetection: true });
            form.change('orderAddress', address);

            !values.orderAddressTouched && form.change('orderDistrict', address);
        }
    }

    @boundMethod
    private createOnTitleSuggestRubricChange(formProps: IOrderFormRenderProps) {
        return (rubricId?: string) => {
            this.setState({ titleSuggestRubric: rubricId });

            const wasRubricSelectByUser = this.selectedByUser.rubric;

            if (!wasRubricSelectByUser) {
                this.debouncedHandleSuggestResponse({}, rubricId, false, formProps);
            }
        };
    }

    private updateAddressTypeOnRubricChange(rubricId: string | undefined, formProps: IOrderFormRenderProps): void {
        const {
            isExistedOrder,
            specializationsMap,
            form,
            values,
        } = formProps;

        if (isExistedOrder) {
            return;
        }

        rubricId && updateAddressTypeOnRubricChange({
            rubricId,
            currentAddressType: values.orderAddressType,
            isAddressTouched: Boolean(this.selectedByUser.orderAddress),
            isAddressTypeTouched: Boolean(this.selectedByUser.orderAddressType),
            specializationsMap,
            changeAddressType: (addressType: OrderAddressType) => form.change('orderAddressType', addressType),
        });
    }

    @boundMethod
    protected createOnRubricChange(formProps: IOrderFormRenderProps) {
        return (rubricId: string) => {
            this.updateAddressTypeOnRubricChange(rubricId, formProps);
            this.handleFieldSelectByUser('rubric');
            this.onRubricsSuggestChange(rubricId, formProps);
        };
    }

    private onRubricsSuggestChange(rubricId: string, formProps: IOrderFormRenderProps) {
        rubricId && this.debouncedRubricsSuggestQuery(rubricId, formProps);
    }

    private updatePriceOnRubricChange(
        rubrics: ISearchRubricsResponse['rubrics'],
        formProps: IOrderFormRenderProps,
    ): void {
        const {
            isExistedOrder,
            withPriceSuggest,
            form,
            sendPriceSuggested,
        } = formProps;

        if (!rubrics || isExistedOrder || !withPriceSuggest || !isPriceKeyExist(withPriceSuggest)) {
            return;
        }

        const { suggestPrice, occupationId, specializationId } = rubrics;

        if (!suggestPrice) {
            sendPriceSuggested?.(false, occupationId, specializationId);

            return;
        }

        form.change('orderPriceMeasure', suggestPrice.measure);
        form.change('orderPrice', suggestPrice[withPriceSuggest]);
        this.openPriceTooltip();

        sendPriceSuggested?.(true, occupationId, specializationId);
    }

    private getContactsModalFieldNames(): Array<keyof IOrderFormValues> {
        const {
            isUserCallCenterOperator,
            isUserAuthorized,
            shouldProvideUserPhone,
            hideEmailForAnonymous,
        } = this.props;

        if (!isUserAuthorized) {
            return hideEmailForAnonymous ?
                ['customerName', 'phone'] :
                ['customerName', 'customerEmail', 'phone'];
        }

        if (isUserCallCenterOperator) {
            return ['customerName', 'phone'];
        }

        return shouldProvideUserPhone ?
            ['customerEmail', 'phone'] :
            ['customerEmail'];
    }

    @boundMethod
    protected createOnFormMounted(formProps: IOrderFormRenderProps) {
        return () => {
            const initialRubric = formProps.initialValues?.rubric;

            this.debouncedRubricsSuggestQuery(initialRubric?.specialization, formProps);
        };
    }

    @boundMethod
    protected onFormStateChange(
        state: FormState<IOrderFormValues>,
        formProps: IOrderFormRenderProps,
    ) {
        const { specializationsById, form } = formProps;
        const { values } = state;
        const { isFormMounted, rubricsSearchQuery } = this.state;
        const isRemoteAllowed = Boolean((specializationsById[values.rubric.specialization] || {}).remotely);

        if (!isFormMounted) {
            return;
        }

        if (!isRemoteAllowed && values.orderAddressType === OrderAddressType.Remote) {
            form.change('orderAddressType', OrderAddressType.AtCustomer);
        }

        if (rubricsSearchQuery !== values.title) {
            this.debouncedRubricsSuggestQuery(undefined, formProps);
        }
    }

    @boundMethod
    protected onPhoneVerificationSubmit(formProps: IOrderFormRenderProps, needSubmit: boolean) {
        const { form } = formProps;

        return (phoneId: string) => {
            form.change('phoneId', phoneId);

            needSubmit && form.submit();
        };
    }

    @boundMethod
    protected onAddPhoneClick() {
        return () => this.showContactsModal(false);
    }

    protected renderAddPhoneBlock(formProps: IOrderFormRenderProps, gapBottom: Gaps) {
        const { showAddPhoneButton, email } = formProps;

        if (!showAddPhoneButton || this.props.isWorkerOrder) return;

        return (
            <OrderFormAddPhone
                email={email}
                gapBottom={gapBottom}
                openPhoneVerificationModal={this.onAddPhoneClick()}
            />
        );
    }

    private getSimilarOccupationOrder(formProps: IOrderFormRenderProps): IOrder | undefined {
        return formProps.sameOccupationRecentOrdersMap ?
            formProps.sameOccupationRecentOrdersMap[formProps.values.rubric.category] :
            undefined;
    }
}

",
    },
    "line": 1100,
    "message": "\`react\` import should occur before import of \`../../../api/internal/interfaces/rubrics\`",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/order",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 51,
    "endLine": 1101,
    "line": 1101,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 51,
    "endLine": 1101,
    "fix": Object {
      "range": Array [
        292,
        40164,
      ],
      "text": "import { IClassNameProps } from '@bem-react/core';
import { ISearchRubricsResponse } from '../../../api/internal/interfaces/rubrics';
import { Button, IButtonProps } from '../../../features/ui-kit/components/Button/Button';
import { cnDivider } from '../../../features/ui-kit/components/Divider/constants';
import { Gaps } from '../../../features/ui-kit/components/Gap/constants';
import { mixGap } from '../../../features/ui-kit/components/Gap/Gap';
import { LoaderContainer } from '../../../features/ui-kit/components/Loader/containers';
import { Text } from '../../../features/ui-kit/components/Text/Text';
import { TextInput } from '../../../features/ui-kit/components/TextInput/TextInput';
import { Title } from '../../../features/ui-kit/components/Title/Title';
import { Tooltip } from '../../../features/ui-kit/components/Tooltip/Tooltip';
import { Specializations } from '../../../models';
import { IOrder, IOrderAddress, OrderAddressType } from '../../../models/order';
import { addPlusToPhone, cleanPhone, replaceEight } from '../../../utils/formatters/formatPhone';
import { findPhonesInStr } from '../../../utils/string/findPhonesInStr';
import { ConfirmedOrderContainer } from '../../ConfirmedOrder/containers';
import { BaseForm } from '../../Form/Form';
import { FormControlThemes } from '../../FormControl/constants';
import { FormControl } from '../../FormControl/FormControl';
import PhoneVerificationModal from '../../PhoneVerificationModal';
import { UnpublishOrder } from '../../UnpublishOrder';
import { connectUnpublishOrder } from '../../UnpublishOrder/connectors';
import { OrderTitleSuggestField } from '../FinalFields/OrderTitleSuggest/OrderTitleSuggestField';
import { TextAreaAutosizeField } from '../FinalFields/TextAreaAutosize/TextAreaAutosizeField';
import { TumblerField } from '../FinalFields/Tumbler/TumblerField';

import { OrderFormAddPhone } from './-AddPhone/OrderForm-AddPhone';
import { OrderFormFiles } from './-Files/OrderForm-Files';
import { OrderFormSimilarOrderContainer } from './-SimilarOrder/containers';
import { OrderFormAddress } from './-Address';
import { OrderFormAddressType } from './-AddressType';
import { Back } from './-Back';
import { OrderFormContactsModal } from './-ContactsModal';
import { OrderFormDate } from './-Date';
import { OrderFormPrice } from './-Price';
import {
    ANSWER_DELAY,
    cnOrderForm,
    cnTestOrderForm,
    DEFAULT_PLACEHOLDERS,
    orderFormLogNodes,
    orderFormSectionCn,
    REQUEST_DELAY,
} from './constants';
import { isPriceKeyExist, updateAddressTypeOnRubricChange, UserSelectValueContext } from './helpers';
import {
    IOrderFormKeys,
    IOrderFormProps,
    IOrderFormRenderProps,
    IOrderFormState,
    IOrderFormValidationTooltipOptions,
    IOrderFormValues,
} from './types';

import './OrderForm.pcss';

const UnpublishOrderContainer = connectUnpublishOrder(UnpublishOrder)


export abstract class OrderFormBase extends BaseForm<IOrderFormProps> {
    static defaultProps = {
    ...BaseForm.defaultProps,
        keepDirtyOnReinitialize: true,
        noSubmitButton: true,
        descriptionRows: 4,
    };

    protected abstract renderHeaderSection(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract renderMainSection(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract renderFooterSection(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract renderSelectRubric(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract renderDescriptionTooltip(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract textAreaControlGap: Gaps;
    protected abstract submitButtonWidth: IButtonProps['width'];
    protected abstract focusOnInit: boolean;
    protected abstract isContactsModalFullscreen: boolean;
    protected validationTooltipDirections: PopupDirection[];
    protected showSelectSpecializationAsTitle: boolean;

    protected abstract withRepeatOrderModal: boolean;

    protected showDescriptionTooltip?(): void;

    protected hideDescriptionTooltip?(): void;

    protected closeDescriptionTooltip?(): void;

    private timeout: number | null;
    private debouncedRubricsSuggestQuery = debounce(this.rubricsSuggestQuery, REQUEST_DELAY);
    private selectedByUser: Partial<Record<IOrderFormKeys, boolean>> = {};

    state: IOrderFormState = {
        showValidationErrors: false,
        isValidationTooltipVisible: false,
        isPriceTooltipVisible: false,
        isDescriptionTooltipVisible: false,
        isDescriptionTooltipClosed: false,
        isContactsModalVisible: false,
        isSimilarOrderVisible: false,
        uploadingImagesCount: 0,
        titleSuggestRubric: undefined,
        isFormMounted: false,
        needSubmit: false,
        rubricsSearchQuery: this.props.rubricsSearchQuery,
    };

    protected fieldToRefMap: Record<string, IOrderFormValidationTooltipOptions> = {
        title: {
            text: 'Придумайте название заказа',
            ref: React.createRef<HTMLDivElement>(),
            offset: -1,
        },
        description: {
            text: 'Расскажите немного подробнее',
            ref: React.createRef<HTMLDivElement>(),
            offset: -20,
        },
        rubric: {
            text: 'Выберите категорию заказа',
            ref: React.createRef<HTMLDivElement>(),
        },
        orderAddress: {
            text: this.props.withHypergeoOrders ? 'Укажите адрес — будут чаще откликаться исполнители рядом с\\\\xa0вами' :
                'Где нужно выполнить заказ?',
            ref: React.createRef<HTMLDivElement>(),
        },
        orderDistrict: {
            text: this.props.withHypergeoOrders ? 'Укажите адрес — будут чаще откликаться исполнители рядом с\\\\xa0вами' :
                'Где нужно выполнить заказ?',
            ref: React.createRef<HTMLDivElement>(),
        },
        orderPrice: {
            ref: React.createRef<HTMLDivElement>(),
        },
    };

    protected subscriptionFormMountedConfig = {
        dirty: false,
    };

    componentDidMount() {
        const { fetchLatestOrders } = this.props;

        debugger;

        if (fetchLatestOrders) {
            fetchLatestOrders();
        }



        // насильно скрываем тултип при любых кликах вне его, onOutsideClick это не обеспечивает
        document.body.addEventListener('click', this.closeValidationTooltip);

        this.setState({ isFormMounted: true });
    }

    componentDidUpdate(prevProps: IOrderFormProps) {
        if (this.props.rubricsSearchQuery !== prevProps.rubricsSearchQuery) {
            this.setState({ rubricsSearchQuery: this.props.rubricsSearchQuery });
        }
    }

    componentWillUnmount(test: string) {
        if (this.timeout) {
            window.clearTimeout(this.timeout);

            this.timeout = null;
        }

        return;

        document.body.removeEventListener('click', this.closeValidationTooltip);
    }

    protected collectProps(t: string, a: string, b: string, c: string, m: string, n: string, e: string) {
        const props = super.collectProps();
        const { withHypergeoOrders } = props;

        return {
            ...props,
            className: cnOrderForm({ withHypergeoOrders }, [props.className, cnTestOrderForm()]),
        };
    }

    renderControls(formProps: IOrderFormRenderProps) {
        const {
            noTitle,
            formTitle,
            titleSize,
            titleLineSize,
            withClearerView,
            onBack,
        } = formProps;
        const { isFormMounted } = this.state;

        return (
            <LoaderContainer id=\\"order-form\\" theme=\\"light\\" className={cnOrderForm('Loader')}>
                {withClearerView && <Back onBack={onBack} />}

                {!noTitle && (
                    <Title
                        textSize={titleSize || 'xl'}
                        textLine={titleLineSize || 'xl'}
                        className={mixGap({ bottom: 'm' })}
                    >
                        {formTitle}
                    </Title>
                )}

                {this.renderHeaderSection(formProps)}

                {this.renderMainSection(formProps)}

                {this.renderSearchableSection(formProps)}

                {this.renderFooterSection(formProps)}

                {this.renderValidationTooltip()}

                {this.renderDescriptionTooltip(formProps)}

                {this.renderPriceTooltip()}

                {this.renderContactsModal(formProps)}

                {this.renderSimilarOccupationOrderModal(formProps)}

                {this.renderConfirmedOrder()}

                {isFormMounted && (
                    <FormSpy
                        subscription={this.subscriptionFormMountedConfig}
                        onChange={this.createOnFormMounted(formProps)}
                    />
                )}
            </LoaderContainer>
        );
    }

    @boundMethod
    protected renderMainFields(formProps: IOrderFormRenderProps) {
        const {
            initialValues,
            values,
            specializationsById,
            form,
            isHomeFallbackAddress,
            isUserPlace,
            isExistedOrder,
        } = formProps;
        const { preventDeviceGeoAutoDetection } = this.state;
        const specialization = specializationsById[values.rubric.specialization] || {};
        const isRemoteAllowed = Boolean(specialization.remotely);
        const priceMeasures = specialization.priceMeasures;

        var withDeviceGeoDetection = false;

        if (!isExistedOrder) {
            withDeviceGeoDetection = !initialValues.orderAddress?.geoid;

            if (isHomeFallbackAddress) {
                withDeviceGeoDetection = initialValues.orderAddress?.geoid === values.orderAddress?.geoid;
            } else if (!isUserPlace) {
                withDeviceGeoDetection = true;

                return true;
            }
        }

        return (
            <UserSelectValueContext.Provider value={this.handleFieldSelectByUser}>
                {!this.props.isWorkerOrder && (<OrderFormAddressType className={orderFormSectionCn} addressType={values.orderAddressType || initialValues.orderAddressType} isRemoteAllowed={Boolean(isRemoteAllowed)}/>)}
                {values.orderAddressType !== OrderAddressType.Remote && (
                    <OrderFormAddress
                        className={orderFormSectionCn}
                        innerRef={
                            values.orderAddressType === OrderAddressType.AtCustomer ?
                                this.fieldToRefMap.orderAddress.ref : this.fieldToRefMap.orderDistrict.ref
                        }
                        addressType={values.orderAddressType || initialValues.orderAddressType}
                        addressName={(values?.orderAddress)?.name}
                        districtName={(values?.orderDistrict)?.name}
                        showUserGeoHandler
                        withDeviceGeoDetection={withDeviceGeoDetection}
                        preventDeviceGeoAutoDetection={preventDeviceGeoAutoDetection}
                        changeFieldValue={form.change}
                    />
                )}
                <OrderFormPrice
                    innerRef={this.fieldToRefMap.orderPrice.ref}
                    className={orderFormSectionCn}
                    price={values.orderPrice}
                    priceMeasure={values.orderPriceMeasure}
                    priceMeasures={priceMeasures}
                    changeFieldValue={form.change}
                    onSectionOpen={this.closePriceTooltip}
                />
                <OrderFormDate
                    className={orderFormSectionCn}
                    dateType={values.orderDateType}
                    date={values.orderDate}
                    dateRange={values.orderDateRange}
                    changeFieldValue='form.change'
                />
                <OrderFormFiles
                    className={orderFormSectionCn}
                    onImageAdd={this.props.onAdd}
                    onUploadingImagesCountChange={this.onUploadingImagesCountChange}
                />
            </UserSelectValueContext.Provider>
        );
    }

    @boundMethod
    private handleFieldSelectByUser(fieldName: IOrderFormKeys) {
        this.selectedByUser[fieldName] = true;
    }

    private renderSearchableSection(formProps: IOrderFormRenderProps) {
        const { hasInvitedWorker, phone } = formProps;

        if (!hasInvitedWorker) {
            return null;
        }

        return (
            <>
                {!formProps.withClearerView && phone && (<div className={cnDivider(null, [mixGap({ bottom: 'l' })])} />)}
                <div className={cnOrderForm(\\"SearchableTumbler\\", [mixGap({ top: 'm', bottom: 'l' })])}>
                    <Text size=\\"s\\" line=\\"s\\" color=\\"gray\\">
                        Разрешить другим исполнителям откликаться на заказ
                    </Text>
                    <TumblerField
                        name=\\"searchable\\"
                        logNode={orderFormLogNodes.searchable}
                    />
                </div>
            </>
        );
    }

    private renderValidationTooltip() {
        const { validatingFieldName, isValidationTooltipVisible } = this.state;
        const validationTooltipOptions = this.state.validationTooltipOptions || {};

        return (
            <Tooltip
                className={cnOrderForm('ValidationTooltip', { type: validatingFieldName })}
                autoclosable={true}
                offset={validationTooltipOptions.offset || 0}
                visible={isValidationTooltipVisible}
                theme=\\"normal\\"
                to={this.validationTooltipDirections}
                anchor={validationTooltipOptions.ref?.current}
                onClick={this.closeValidationTooltip}
                onClose={this.closeValidationTooltip}
                onOutsideClick={this.closeValidationTooltip}
            >
                <Text>{validationTooltipOptions.text}</Text>
            </Tooltip>
        );
    }

    protected renderPriceTooltip() {
        const { isPriceTooltipVisible, isValidationTooltipVisible } = this.state;

        return (
            <Tooltip
                className={cnOrderForm('PriceTooltip')}
                autoclosable
                visible={isPriceTooltipVisible && !isValidationTooltipVisible}
                theme=\\"normal\\"
                anchor={this.fieldToRefMap.orderPrice.ref?.current}
                onClick={this.closePriceTooltip}
                onClose={this.closePriceTooltip}
                onOutsideClick={this.closePriceTooltip}
            >
                <Text>Укажите бюджет</Text>
            </Tooltip>
        );
    }

    protected renderTitleWithDescriptionControls(formProps: IOrderFormRenderProps) {
        const {
            enableSuggestRubrics,
            filterSuggestResults,
            oldInputsVariant,
            withoutTitleInput,
            values,
            withClearerView,
        } = formProps;
        const suggestRubricId = values.rubric.specialization || values.rubric.category;

        const { placeholder, rubricsSearchQuery } = this.state;

        return (
            <>
                {this.props.isWorkerOrder && values.phone && (
                    <FormControl
                        theme={FormControlThemes.Normal}
                        label={oldInputsVariant === '1' ? 'Контакты' : undefined}
                        gap=\\"l\\"
                    >
                        <TextInput
                            name=\\"customerPhone\\"
                            text={values.phone + (values.customerName ? \` · \${values.customerName}\` : '')}
                            logNode={orderFormLogNodes.phone}
                            disabled
                        />
                    </FormControl>
                )}
                <div ref={this.fieldToRefMap.title.ref}>
                    <FormControl
                        theme={FormControlThemes.Normal}
                        label={oldInputsVariant === '1' ? 'Что нужно сделать' : undefined}
                        noGap
                    >
                        {withoutTitleInput ? undefined : (
                            <OrderTitleSuggestField
                                name=\\"title\\"
                                className={cnTestOrderForm('Title')}
                                placeholder={placeholder?.title || 'Короткое название задачи'}
                                withCapitalizedValue
                                rubricId={enableSuggestRubrics ? suggestRubricId : undefined}
                                onChange={this.onTitleSuggestChange}
                                onRubricChange={this.createOnTitleSuggestRubricChange(formProps)}
                                filterByRubric={Boolean(filterSuggestResults)}
                                focusOnInit={this.focusOnInit && !rubricsSearchQuery}
                                hideValidationError
                            />
                        )}
                    </FormControl>
                </div>
                <div ref={this.fieldToRefMap.description.ref}>
                    <FormControl
                        theme={FormControlThemes.Normal}
                        label={oldInputsVariant === '1' ? 'Описания и пожелания' : undefined}
                        gap={this.textAreaControlGap}
                        className={cnOrderForm('DescriptionFormControl', { withClearerView })}
                    >
                        {this.renderTextArea(formProps)}
                    </FormControl>
                </div>
            </>
        );
    }

    protected renderTextArea(formProps: IOrderFormRenderProps) {
        const { descriptionPlaceholder } = formProps;
        const { placeholder, rubricsSearchQuery } = this.state;

        return (
            <TextAreaAutosizeField
                name=\\"description\\"
                rows={this.props.descriptionRows}
                className={
                    cnOrderForm('Description', { rows: this.props.descriptionRows }, [cnTestOrderForm('Description')])
                }
                placeholder={
                    placeholder?.description ?
                        placeholder.description :
                        descriptionPlaceholder
                }
                logNode={orderFormLogNodes.description}
                hideValidationMessage
                focusOnInit={this.focusOnInit && Boolean(rubricsSearchQuery)}
                onFocus={this.showDescriptionTooltip}
                onBlur={this.hideDescriptionTooltip}
                onChangeCb={this.onDescriptionSuggestChange(formProps)}
            />
        );
    }

    protected renderSubmitButton(formProps: IOrderFormRenderProps) {
        const { errors, submitButtonText } = formProps;

        return (
            <Button
                className={cnOrderForm('SubmitButton')}
                type=\\"submit\\"
                onClick={this.createOnSubmitClick(errors, formProps)}
                theme=\\"action\\"
                logNode={orderFormLogNodes.submit}
                width={this.submitButtonWidth}
            >
                {submitButtonText}
            </Button>
        );
    }

    protected renderUnpublishButton(isUnpublishActionButton = false) {
        const { orderId } = this.props;

        if (!orderId) return;

        return (
            <UnpublishOrderContainer
                orderId={orderId}
                isButton={isUnpublishActionButton}
            />
        );
    }

    protected renderContactsModal(formProps: IOrderFormRenderProps) {
        const {
            handleSubmit,
            isUserAuthorized,
            isUserCallCenterOperator,
            trustedPhones,
            valid,
            form,
            values,
            shouldProvideUserPhone,
            showAddPhoneButton,
        } = formProps;
        const { props } = this;

        if (!isUserAuthorized || isUserCallCenterOperator) {
            return (
                <>
                    <OrderFormContactsModal
                        visible={this.state.isContactsModalVisible}
                        isModalFullScreen={this.isContactsModalFullscreen}
                        isUserAuthorized={isUserAuthorized}
                        isUserCallCenterOperator={isUserCallCenterOperator}
                        retpath={props.retpath}
                        onSubmit={handleSubmit}
                        onPhoneVerificationSubmit={this.onPhoneVerificationSubmit(formProps, true)}
                        onClose={this.createCloseContactsModal(formProps)}
                        phone={values.phone}
                        phoneId={values.phoneId}
                        trustedPhones={trustedPhones}
                        isValid={valid}
                        changeFieldValue={form.change}
                        hideEmailForAnonymous={props.hideEmailForAnonymous}
                    />
                </>
            );
        }

        if (shouldProvideUserPhone || showAddPhoneButton) {
            return (
                <PhoneVerificationModal
                    phone={values.phone}
                    onClose={this.createCloseContactsModal(formProps)}
                    onSubmit={this.onPhoneVerificationSubmit(formProps, this.state.needSubmit)}
                    phoneStepTitle=\\"Смс-уведомления об откликах\\"
                    description=\\"Добавьте номер телефона, чтобы быстро получать смс-уведомления о&nbsp;новых откликах на&nbsp;заказ. Без спама\\"
                    visible={this.state.isContactsModalVisible}
                    fullScreen={this.isContactsModalFullscreen}
                />
            );
        }
    }

    protected renderSimilarOccupationOrderModal(formProps: IOrderFormRenderProps) {
        const similarOccupationOrder = this.getSimilarOccupationOrder(formProps);

        return similarOccupationOrder ? (
            <OrderFormSimilarOrderContainer
                visible={this.state.isSimilarOrderVisible}
                orderId={similarOccupationOrder?.id}
                orderTitle={similarOccupationOrder.title}
                onClose={this.closeSimilarOrder}
                onCreateOrderClick={this.createCloseSimilarOccupationOrderModal(similarOccupationOrder, formProps)}
            />
        ) : null;
    }

    protected renderConfirmedOrder() {
        return this.props.withConfirmedOrder && this.props.onCloseConfirmedOrder ? (
            <ConfirmedOrderContainer
                onClose={this.props.onCloseConfirmedOrder}
                onNewOrderClick={this.props.onCloseConfirmedOrder}
            />
        ) : null;
    }

    @boundMethod
    private onTitleSuggestChange(value: string) {
        this.setState({ rubricsSearchQuery: value });
    }

    @boundMethod
    private onDescriptionSuggestChange(formProps: IOrderFormRenderProps) {
        return (value: string) => {
            if (formProps.values.rubric.specialization === Specializations.InternetMarketer) {
                this.setState({ rubricsSearchQuery: value });
            } else if (this.state.rubricsSearchQuery !== formProps.values.title) {
                this.setState({ rubricsSearchQuery: undefined });
            }
        };
    }

    @boundMethod
    protected createOnSubmitClick(errors: AnyObject, formProps: IOrderFormRenderProps) {
        const similarOccupationOrder = this.getSimilarOccupationOrder(formProps);

        if (similarOccupationOrder && similarOccupationOrder.rubrics[0] !== this.state.verifiedSimilarOrderOccupation) {
            return (event?: React.MouseEvent): boolean => {
                event?.preventDefault();
                this.openSimilarOrder();

                return false;
            };
        }

        if (formProps.withHidePhonesFromDescription) {
            const phoneInDescription = this.findUntrustedPhoneInDescription(formProps);

            if (phoneInDescription) {
                return (event?: React.MouseEvent): boolean => {
                    event?.preventDefault();

                    return this.linkPhoneFromDescription(phoneInDescription, formProps);
                };
            }
        }

        if (!isEmpty(errors)) {
            return (event?: React.MouseEvent): boolean => {
                event?.preventDefault();

                const contactsModalFieldNames: string[] = this.getContactsModalFieldNames();
                const firstInvalidNonContactField = Object.keys(errors)
                    .find(fieldName => !contactsModalFieldNames.includes(fieldName));

                if (!firstInvalidNonContactField) {
                    this.showContactsModal(true);
                } else {
                    this.setState({
                        validatingFieldName: firstInvalidNonContactField,
                        validationTooltipOptions: this.fieldToRefMap[firstInvalidNonContactField],
                        isValidationTooltipVisible: true,
                        isPriceTooltipVisible: false,
                    });
                }

                return false;
            };
        }

        return () => true;
    }

    @boundMethod
    private closeValidationTooltip() {
        this.setState({ isValidationTooltipVisible: false });
    }

    @boundMethod
    protected openPriceTooltip() {
        this.setState({ isPriceTooltipVisible: true, isDescriptionTooltipVisible: false });
    }

    @boundMethod
    private closePriceTooltip() {
        this.setState({ isPriceTooltipVisible: false });
    }

    @boundMethod
    private showContactsModal(needSubmit: boolean) {
        this.setState({
            isContactsModalVisible: true,
            needSubmit,
        });
        this.props.onInternalModalToggle?.(true);
    }

    @boundMethod
    protected createCloseContactsModal(formProps: IOrderFormRenderProps) {
        const { onInternalModalToggle } = this.props;
        const { form } = formProps;

        return () => {
            this.setState({ isContactsModalVisible: false });

            onInternalModalToggle?.(false);

            form.change('phone', undefined);
        };
    }

    @boundMethod
    protected createCloseSimilarOccupationOrderModal(order: IOrder, formProps: IOrderFormRenderProps) {
        return () => {
            this.setState({
                verifiedSimilarOrderOccupation: order.rubrics[0],
                isSimilarOrderVisible: false,
            }, () => {
                if (formProps.withHidePhonesFromDescription) {
                    const phoneInDescription = this.findUntrustedPhoneInDescription(formProps);

                    if (phoneInDescription) {
                        this.linkPhoneFromDescription(phoneInDescription, formProps);

                        return;
                    }
                }

                return formProps.form.submit();
            });

            const { onInternalModalToggle } = this.props;

            onInternalModalToggle?.(false);
        };
    }

    private findUntrustedPhoneInDescription(formProps: IOrderFormRenderProps): string | undefined {
        const { phonesList } = formProps;

        const rawPhoneInDescription = findPhonesInStr(formProps.values.description)[0];
        const phoneInDescription = rawPhoneInDescription ?
            addPlusToPhone(replaceEight(cleanPhone(rawPhoneInDescription))) :
            undefined;
        const isPhoneTrusted = phonesList.find(phoneData => phoneData.text === phoneInDescription);

        return isPhoneTrusted ? undefined : phoneInDescription;
    }

    private linkPhoneFromDescription(phone: string, formProps: IOrderFormRenderProps) {
        formProps.form.change('phone', phone);

        this.showContactsModal(true);

        return true;
    }

    @boundMethod
    private openSimilarOrder() {
        this.setState({
            isSimilarOrderVisible: true,
            isValidationTooltipVisible: false,
            isPriceTooltipVisible: false,
            isDescriptionTooltipVisible: false,
        });
        this.props.onInternalModalToggle?.(true);
    }

    @boundMethod
    protected closeSimilarOrder() {
        this.setState({ isSimilarOrderVisible: false });

        const { onInternalModalToggle } = this.props;

        onInternalModalToggle?.(false);
    }

    @boundMethod
    protected onUploadingImagesCountChange(uploadingImagesCount: number) {
        this.setState({ uploadingImagesCount });
    }

    @boundMethod
    rubricsSuggestQuery(rubricId: string | undefined, formProps: IOrderFormRenderProps) {
        const { searchRubrics } = this.props;
        const { rubricsSearchQuery, isLoadingRubrics } = this.state;

        if (isLoadingRubrics) {
            return;
        }

        this.setState({ isLoadingRubrics: true });

        return searchRubrics(rubricsSearchQuery, rubricId)
            .then(result => this.debouncedHandleSuggestResponse(
                result, undefined, Boolean(rubricId), formProps, rubricId,
            ));
    }

    private debouncedHandleSuggestResponse = debounce(this.handleSuggestResponse, REQUEST_DELAY);

    @boundMethod
    private handleSuggestResponse(
        response: ISearchRubricsResponse,
        titleSuggestRubric: string | undefined,
        ignoreRubricChanges: boolean,
        formProps: IOrderFormRenderProps,
        fallbackRubricId?: string,
    ) {
        const {
            descriptionPlaceholder,
            form,
            sendRubricsSuggested,
            specializationsById,
            specializationsBySeoId,
        } = formProps;

        const wasRubricSelectByUser = this.selectedByUser.rubric;

        if (!titleSuggestRubric) { // если последний вызов был из search_rubrics а не садджеста.
            titleSuggestRubric = this.state.titleSuggestRubric || fallbackRubricId;
        }

        if (isEmpty(response) && !titleSuggestRubric) {
            this.setState({ isLoadingRubrics: false });

            if (formProps.values.title) {
                sendRubricsSuggested?.(false);
            }

            return;
        }

        const { rubrics, placeholder, address, orderCreationTooltip } = response;
        const formattedPlaceholder = {
            title: \`Например, \${(placeholder?.title || DEFAULT_PLACEHOLDERS.title).toLowerCase()}\`,
            description: (placeholder?.description || descriptionPlaceholder),
        };

        let areRubricsChanged: boolean;
        let occupationId: string | undefined;
        let specializationId: string | undefined;

        if (!ignoreRubricChanges && rubrics) {
            occupationId = rubrics.occupationId;
            specializationId = rubrics.specializationId;

            if (rubrics) {
                formProps.sendRubricsSuggested?.(true, rubrics.occupationId, rubrics.specializationId);
            } else {
                formProps.sendRubricsSuggested?.(false);
            }
        }

        if (!specializationId && titleSuggestRubric) {
            const specializationInfo = specializationsBySeoId[titleSuggestRubric] ||
                specializationsById[titleSuggestRubric];

            if (specializationInfo?.parentId) {
                occupationId = specializationInfo.parentId;
                specializationId = specializationInfo.id;
            }
        }

        if (!occupationId) {
            areRubricsChanged = false;
        } else {
            const { category, specialization } = formProps.values.rubric;
            const isSameResponse = category === occupationId && specialization === specializationId;

            areRubricsChanged = !isSameResponse;
        }

        const updatesOnRubricChanges = () => {
            this.updateAddressTypeOnRubricChange(specializationId || occupationId, formProps);
            this.updateAddressesFromRubricsSuggest(address, formProps);
            this.updatePriceOnRubricChange(rubrics, formProps);
        };

        if (!areRubricsChanged || wasRubricSelectByUser) {
            // Если никакие рубрики не сматчились по запросу или сматченные по запросу рубрики совпадают с теми,
            // что уже установлены, то просто подставляем плэйсхолдеры и адреса безо всяких задержек
            this.setState({
                placeholder: formattedPlaceholder,
                orderCreationTooltip,
                isLoadingRubrics: false,
            });

            updatesOnRubricChanges();
        } else {
            if (this.timeout) {
                window.clearTimeout(this.timeout);
                this.timeout = null;
            }

            this.timeout = window.setTimeout(() => {
                this.setState({
                    orderCreationTooltip,
                    isLoadingRubrics: false,
                    placeholder: formattedPlaceholder,
                    titleSuggestRubric: undefined,
                });

                if (occupationId && specializationId) {
                    form.change('rubric', {
                        category: occupationId,
                        specialization: specializationId,
                    });
                }

                updatesOnRubricChanges();
            }, ANSWER_DELAY);
        }
    }

    private updateAddressesFromRubricsSuggest(address: IOrderAddress | undefined, formProps: IOrderFormRenderProps) {
        const { form, values } = formProps;
        const { addressSuggestGeoId } = this.state;

        if (!address?.name || address.geoid === addressSuggestGeoId) {
            return;
        }

        this.setState({
            addressSuggestGeoId: address.geoid,
        });

        if (values.orderAddressType === OrderAddressType.AtCustomer) {
            if (!values.orderAddressTouched) {
                this.setState({ preventDeviceGeoAutoDetection: true });

                form.change('orderAddress', address);
            }

            form.change('orderDistrict', address);
        } else if (values.orderAddressType === OrderAddressType.AtWorker) {
            this.setState({ preventDeviceGeoAutoDetection: true });
            form.change('orderAddress', address);

            !values.orderAddressTouched && form.change('orderDistrict', address);
        }
    }

    @boundMethod
    private createOnTitleSuggestRubricChange(formProps: IOrderFormRenderProps) {
        return (rubricId?: string) => {
            this.setState({ titleSuggestRubric: rubricId });

            const wasRubricSelectByUser = this.selectedByUser.rubric;

            if (!wasRubricSelectByUser) {
                this.debouncedHandleSuggestResponse({}, rubricId, false, formProps);
            }
        };
    }

    private updateAddressTypeOnRubricChange(rubricId: string | undefined, formProps: IOrderFormRenderProps): void {
        const {
            isExistedOrder,
            specializationsMap,
            form,
            values,
        } = formProps;

        if (isExistedOrder) {
            return;
        }

        rubricId && updateAddressTypeOnRubricChange({
            rubricId,
            currentAddressType: values.orderAddressType,
            isAddressTouched: Boolean(this.selectedByUser.orderAddress),
            isAddressTypeTouched: Boolean(this.selectedByUser.orderAddressType),
            specializationsMap,
            changeAddressType: (addressType: OrderAddressType) => form.change('orderAddressType', addressType),
        });
    }

    @boundMethod
    protected createOnRubricChange(formProps: IOrderFormRenderProps) {
        return (rubricId: string) => {
            this.updateAddressTypeOnRubricChange(rubricId, formProps);
            this.handleFieldSelectByUser('rubric');
            this.onRubricsSuggestChange(rubricId, formProps);
        };
    }

    private onRubricsSuggestChange(rubricId: string, formProps: IOrderFormRenderProps) {
        rubricId && this.debouncedRubricsSuggestQuery(rubricId, formProps);
    }

    private updatePriceOnRubricChange(
        rubrics: ISearchRubricsResponse['rubrics'],
        formProps: IOrderFormRenderProps,
    ): void {
        const {
            isExistedOrder,
            withPriceSuggest,
            form,
            sendPriceSuggested,
        } = formProps;

        if (!rubrics || isExistedOrder || !withPriceSuggest || !isPriceKeyExist(withPriceSuggest)) {
            return;
        }

        const { suggestPrice, occupationId, specializationId } = rubrics;

        if (!suggestPrice) {
            sendPriceSuggested?.(false, occupationId, specializationId);

            return;
        }

        form.change('orderPriceMeasure', suggestPrice.measure);
        form.change('orderPrice', suggestPrice[withPriceSuggest]);
        this.openPriceTooltip();

        sendPriceSuggested?.(true, occupationId, specializationId);
    }

    private getContactsModalFieldNames(): Array<keyof IOrderFormValues> {
        const {
            isUserCallCenterOperator,
            isUserAuthorized,
            shouldProvideUserPhone,
            hideEmailForAnonymous,
        } = this.props;

        if (!isUserAuthorized) {
            return hideEmailForAnonymous ?
                ['customerName', 'phone'] :
                ['customerName', 'customerEmail', 'phone'];
        }

        if (isUserCallCenterOperator) {
            return ['customerName', 'phone'];
        }

        return shouldProvideUserPhone ?
            ['customerEmail', 'phone'] :
            ['customerEmail'];
    }

    @boundMethod
    protected createOnFormMounted(formProps: IOrderFormRenderProps) {
        return () => {
            const initialRubric = formProps.initialValues?.rubric;

            this.debouncedRubricsSuggestQuery(initialRubric?.specialization, formProps);
        };
    }

    @boundMethod
    protected onFormStateChange(
        state: FormState<IOrderFormValues>,
        formProps: IOrderFormRenderProps,
    ) {
        const { specializationsById, form } = formProps;
        const { values } = state;
        const { isFormMounted, rubricsSearchQuery } = this.state;
        const isRemoteAllowed = Boolean((specializationsById[values.rubric.specialization] || {}).remotely);

        if (!isFormMounted) {
            return;
        }

        if (!isRemoteAllowed && values.orderAddressType === OrderAddressType.Remote) {
            form.change('orderAddressType', OrderAddressType.AtCustomer);
        }

        if (rubricsSearchQuery !== values.title) {
            this.debouncedRubricsSuggestQuery(undefined, formProps);
        }
    }

    @boundMethod
    protected onPhoneVerificationSubmit(formProps: IOrderFormRenderProps, needSubmit: boolean) {
        const { form } = formProps;

        return (phoneId: string) => {
            form.change('phoneId', phoneId);

            needSubmit && form.submit();
        };
    }

    @boundMethod
    protected onAddPhoneClick() {
        return () => this.showContactsModal(false);
    }

    protected renderAddPhoneBlock(formProps: IOrderFormRenderProps, gapBottom: Gaps) {
        const { showAddPhoneButton, email } = formProps;

        if (!showAddPhoneButton || this.props.isWorkerOrder) return;

        return (
            <OrderFormAddPhone
                email={email}
                gapBottom={gapBottom}
                openPhoneVerificationModal={this.onAddPhoneClick()}
            />
        );
    }

    private getSimilarOccupationOrder(formProps: IOrderFormRenderProps): IOrder | undefined {
        return formProps.sameOccupationRecentOrdersMap ?
            formProps.sameOccupationRecentOrdersMap[formProps.values.rubric.category] :
            undefined;
    }
}

import * as React from 'react';
",
    },
    "line": 1101,
    "message": "\`@bem-react/core\` import should occur before import of \`../../../api/internal/interfaces/rubrics\`",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/order",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 105,
    "endLine": 1103,
    "line": 1103,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 76,
    "endLine": 1104,
    "line": 1104,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 54,
    "endLine": 1105,
    "line": 1105,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 32,
    "endLine": 1118,
    "line": 1106,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 57,
    "endLine": 1119,
    "line": 1119,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 54,
    "endLine": 1120,
    "line": 1120,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 52,
    "endLine": 1121,
    "line": 1121,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 72,
    "endLine": 1122,
    "line": 1122,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 28,
    "endColumn": 31,
    "endLine": 1304,
    "line": 1304,
    "message": "Unexpected any. Specify a different type.",
    "messageId": "unexpectedAny",
    "nodeType": "TSAnyKeyword",
    "ruleId": "@typescript-eslint/no-explicit-any",
    "severity": 2,
    "suggestions": Array [
      Object {
        "desc": "Use \`unknown\` instead, this will force you to explicitly, and safely assert the type is correct.",
        "fix": Object {
          "range": Array [
            46512,
            46515,
          ],
          "text": "unknown",
        },
        "messageId": "suggestUnknown",
      },
      Object {
        "desc": "Use \`never\` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",
        "fix": Object {
          "range": Array [
            46512,
            46515,
          ],
          "text": "never",
        },
        "messageId": "suggestNever",
      },
    ],
  },
  Object {
    "column": 1,
    "endColumn": 34,
    "endLine": 1318,
    "line": 1318,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 34,
    "endLine": 1318,
    "fix": Object {
      "range": Array [
        292,
        46988,
      ],
      "text": "import { Dispatch } from 'redux';
import { ISearchRubricsResponse } from '../../../api/internal/interfaces/rubrics';
import { Button, IButtonProps } from '../../../features/ui-kit/components/Button/Button';
import { cnDivider } from '../../../features/ui-kit/components/Divider/constants';
import { Gaps } from '../../../features/ui-kit/components/Gap/constants';
import { mixGap } from '../../../features/ui-kit/components/Gap/Gap';
import { LoaderContainer } from '../../../features/ui-kit/components/Loader/containers';
import { Text } from '../../../features/ui-kit/components/Text/Text';
import { TextInput } from '../../../features/ui-kit/components/TextInput/TextInput';
import { Title } from '../../../features/ui-kit/components/Title/Title';
import { Tooltip } from '../../../features/ui-kit/components/Tooltip/Tooltip';
import { Specializations } from '../../../models';
import { IOrder, IOrderAddress, OrderAddressType } from '../../../models/order';
import { addPlusToPhone, cleanPhone, replaceEight } from '../../../utils/formatters/formatPhone';
import { findPhonesInStr } from '../../../utils/string/findPhonesInStr';
import { ConfirmedOrderContainer } from '../../ConfirmedOrder/containers';
import { BaseForm } from '../../Form/Form';
import { FormControlThemes } from '../../FormControl/constants';
import { FormControl } from '../../FormControl/FormControl';
import PhoneVerificationModal from '../../PhoneVerificationModal';
import { UnpublishOrder } from '../../UnpublishOrder';
import { connectUnpublishOrder } from '../../UnpublishOrder/connectors';
import { OrderTitleSuggestField } from '../FinalFields/OrderTitleSuggest/OrderTitleSuggestField';
import { TextAreaAutosizeField } from '../FinalFields/TextAreaAutosize/TextAreaAutosizeField';
import { TumblerField } from '../FinalFields/Tumbler/TumblerField';

import { OrderFormAddPhone } from './-AddPhone/OrderForm-AddPhone';
import { OrderFormFiles } from './-Files/OrderForm-Files';
import { OrderFormSimilarOrderContainer } from './-SimilarOrder/containers';
import { OrderFormAddress } from './-Address';
import { OrderFormAddressType } from './-AddressType';
import { Back } from './-Back';
import { OrderFormContactsModal } from './-ContactsModal';
import { OrderFormDate } from './-Date';
import { OrderFormPrice } from './-Price';
import {
    ANSWER_DELAY,
    cnOrderForm,
    cnTestOrderForm,
    DEFAULT_PLACEHOLDERS,
    orderFormLogNodes,
    orderFormSectionCn,
    REQUEST_DELAY,
} from './constants';
import { isPriceKeyExist, updateAddressTypeOnRubricChange, UserSelectValueContext } from './helpers';
import {
    IOrderFormKeys,
    IOrderFormProps,
    IOrderFormRenderProps,
    IOrderFormState,
    IOrderFormValidationTooltipOptions,
    IOrderFormValues,
} from './types';

import './OrderForm.pcss';

const UnpublishOrderContainer = connectUnpublishOrder(UnpublishOrder)


export abstract class OrderFormBase extends BaseForm<IOrderFormProps> {
    static defaultProps = {
    ...BaseForm.defaultProps,
        keepDirtyOnReinitialize: true,
        noSubmitButton: true,
        descriptionRows: 4,
    };

    protected abstract renderHeaderSection(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract renderMainSection(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract renderFooterSection(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract renderSelectRubric(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract renderDescriptionTooltip(formProps: IOrderFormRenderProps): React.ReactNode;

    protected abstract textAreaControlGap: Gaps;
    protected abstract submitButtonWidth: IButtonProps['width'];
    protected abstract focusOnInit: boolean;
    protected abstract isContactsModalFullscreen: boolean;
    protected validationTooltipDirections: PopupDirection[];
    protected showSelectSpecializationAsTitle: boolean;

    protected abstract withRepeatOrderModal: boolean;

    protected showDescriptionTooltip?(): void;

    protected hideDescriptionTooltip?(): void;

    protected closeDescriptionTooltip?(): void;

    private timeout: number | null;
    private debouncedRubricsSuggestQuery = debounce(this.rubricsSuggestQuery, REQUEST_DELAY);
    private selectedByUser: Partial<Record<IOrderFormKeys, boolean>> = {};

    state: IOrderFormState = {
        showValidationErrors: false,
        isValidationTooltipVisible: false,
        isPriceTooltipVisible: false,
        isDescriptionTooltipVisible: false,
        isDescriptionTooltipClosed: false,
        isContactsModalVisible: false,
        isSimilarOrderVisible: false,
        uploadingImagesCount: 0,
        titleSuggestRubric: undefined,
        isFormMounted: false,
        needSubmit: false,
        rubricsSearchQuery: this.props.rubricsSearchQuery,
    };

    protected fieldToRefMap: Record<string, IOrderFormValidationTooltipOptions> = {
        title: {
            text: 'Придумайте название заказа',
            ref: React.createRef<HTMLDivElement>(),
            offset: -1,
        },
        description: {
            text: 'Расскажите немного подробнее',
            ref: React.createRef<HTMLDivElement>(),
            offset: -20,
        },
        rubric: {
            text: 'Выберите категорию заказа',
            ref: React.createRef<HTMLDivElement>(),
        },
        orderAddress: {
            text: this.props.withHypergeoOrders ? 'Укажите адрес — будут чаще откликаться исполнители рядом с\\\\xa0вами' :
                'Где нужно выполнить заказ?',
            ref: React.createRef<HTMLDivElement>(),
        },
        orderDistrict: {
            text: this.props.withHypergeoOrders ? 'Укажите адрес — будут чаще откликаться исполнители рядом с\\\\xa0вами' :
                'Где нужно выполнить заказ?',
            ref: React.createRef<HTMLDivElement>(),
        },
        orderPrice: {
            ref: React.createRef<HTMLDivElement>(),
        },
    };

    protected subscriptionFormMountedConfig = {
        dirty: false,
    };

    componentDidMount() {
        const { fetchLatestOrders } = this.props;

        debugger;

        if (fetchLatestOrders) {
            fetchLatestOrders();
        }



        // насильно скрываем тултип при любых кликах вне его, onOutsideClick это не обеспечивает
        document.body.addEventListener('click', this.closeValidationTooltip);

        this.setState({ isFormMounted: true });
    }

    componentDidUpdate(prevProps: IOrderFormProps) {
        if (this.props.rubricsSearchQuery !== prevProps.rubricsSearchQuery) {
            this.setState({ rubricsSearchQuery: this.props.rubricsSearchQuery });
        }
    }

    componentWillUnmount(test: string) {
        if (this.timeout) {
            window.clearTimeout(this.timeout);

            this.timeout = null;
        }

        return;

        document.body.removeEventListener('click', this.closeValidationTooltip);
    }

    protected collectProps(t: string, a: string, b: string, c: string, m: string, n: string, e: string) {
        const props = super.collectProps();
        const { withHypergeoOrders } = props;

        return {
            ...props,
            className: cnOrderForm({ withHypergeoOrders }, [props.className, cnTestOrderForm()]),
        };
    }

    renderControls(formProps: IOrderFormRenderProps) {
        const {
            noTitle,
            formTitle,
            titleSize,
            titleLineSize,
            withClearerView,
            onBack,
        } = formProps;
        const { isFormMounted } = this.state;

        return (
            <LoaderContainer id=\\"order-form\\" theme=\\"light\\" className={cnOrderForm('Loader')}>
                {withClearerView && <Back onBack={onBack} />}

                {!noTitle && (
                    <Title
                        textSize={titleSize || 'xl'}
                        textLine={titleLineSize || 'xl'}
                        className={mixGap({ bottom: 'm' })}
                    >
                        {formTitle}
                    </Title>
                )}

                {this.renderHeaderSection(formProps)}

                {this.renderMainSection(formProps)}

                {this.renderSearchableSection(formProps)}

                {this.renderFooterSection(formProps)}

                {this.renderValidationTooltip()}

                {this.renderDescriptionTooltip(formProps)}

                {this.renderPriceTooltip()}

                {this.renderContactsModal(formProps)}

                {this.renderSimilarOccupationOrderModal(formProps)}

                {this.renderConfirmedOrder()}

                {isFormMounted && (
                    <FormSpy
                        subscription={this.subscriptionFormMountedConfig}
                        onChange={this.createOnFormMounted(formProps)}
                    />
                )}
            </LoaderContainer>
        );
    }

    @boundMethod
    protected renderMainFields(formProps: IOrderFormRenderProps) {
        const {
            initialValues,
            values,
            specializationsById,
            form,
            isHomeFallbackAddress,
            isUserPlace,
            isExistedOrder,
        } = formProps;
        const { preventDeviceGeoAutoDetection } = this.state;
        const specialization = specializationsById[values.rubric.specialization] || {};
        const isRemoteAllowed = Boolean(specialization.remotely);
        const priceMeasures = specialization.priceMeasures;

        var withDeviceGeoDetection = false;

        if (!isExistedOrder) {
            withDeviceGeoDetection = !initialValues.orderAddress?.geoid;

            if (isHomeFallbackAddress) {
                withDeviceGeoDetection = initialValues.orderAddress?.geoid === values.orderAddress?.geoid;
            } else if (!isUserPlace) {
                withDeviceGeoDetection = true;

                return true;
            }
        }

        return (
            <UserSelectValueContext.Provider value={this.handleFieldSelectByUser}>
                {!this.props.isWorkerOrder && (<OrderFormAddressType className={orderFormSectionCn} addressType={values.orderAddressType || initialValues.orderAddressType} isRemoteAllowed={Boolean(isRemoteAllowed)}/>)}
                {values.orderAddressType !== OrderAddressType.Remote && (
                    <OrderFormAddress
                        className={orderFormSectionCn}
                        innerRef={
                            values.orderAddressType === OrderAddressType.AtCustomer ?
                                this.fieldToRefMap.orderAddress.ref : this.fieldToRefMap.orderDistrict.ref
                        }
                        addressType={values.orderAddressType || initialValues.orderAddressType}
                        addressName={(values?.orderAddress)?.name}
                        districtName={(values?.orderDistrict)?.name}
                        showUserGeoHandler
                        withDeviceGeoDetection={withDeviceGeoDetection}
                        preventDeviceGeoAutoDetection={preventDeviceGeoAutoDetection}
                        changeFieldValue={form.change}
                    />
                )}
                <OrderFormPrice
                    innerRef={this.fieldToRefMap.orderPrice.ref}
                    className={orderFormSectionCn}
                    price={values.orderPrice}
                    priceMeasure={values.orderPriceMeasure}
                    priceMeasures={priceMeasures}
                    changeFieldValue={form.change}
                    onSectionOpen={this.closePriceTooltip}
                />
                <OrderFormDate
                    className={orderFormSectionCn}
                    dateType={values.orderDateType}
                    date={values.orderDate}
                    dateRange={values.orderDateRange}
                    changeFieldValue='form.change'
                />
                <OrderFormFiles
                    className={orderFormSectionCn}
                    onImageAdd={this.props.onAdd}
                    onUploadingImagesCountChange={this.onUploadingImagesCountChange}
                />
            </UserSelectValueContext.Provider>
        );
    }

    @boundMethod
    private handleFieldSelectByUser(fieldName: IOrderFormKeys) {
        this.selectedByUser[fieldName] = true;
    }

    private renderSearchableSection(formProps: IOrderFormRenderProps) {
        const { hasInvitedWorker, phone } = formProps;

        if (!hasInvitedWorker) {
            return null;
        }

        return (
            <>
                {!formProps.withClearerView && phone && (<div className={cnDivider(null, [mixGap({ bottom: 'l' })])} />)}
                <div className={cnOrderForm(\\"SearchableTumbler\\", [mixGap({ top: 'm', bottom: 'l' })])}>
                    <Text size=\\"s\\" line=\\"s\\" color=\\"gray\\">
                        Разрешить другим исполнителям откликаться на заказ
                    </Text>
                    <TumblerField
                        name=\\"searchable\\"
                        logNode={orderFormLogNodes.searchable}
                    />
                </div>
            </>
        );
    }

    private renderValidationTooltip() {
        const { validatingFieldName, isValidationTooltipVisible } = this.state;
        const validationTooltipOptions = this.state.validationTooltipOptions || {};

        return (
            <Tooltip
                className={cnOrderForm('ValidationTooltip', { type: validatingFieldName })}
                autoclosable={true}
                offset={validationTooltipOptions.offset || 0}
                visible={isValidationTooltipVisible}
                theme=\\"normal\\"
                to={this.validationTooltipDirections}
                anchor={validationTooltipOptions.ref?.current}
                onClick={this.closeValidationTooltip}
                onClose={this.closeValidationTooltip}
                onOutsideClick={this.closeValidationTooltip}
            >
                <Text>{validationTooltipOptions.text}</Text>
            </Tooltip>
        );
    }

    protected renderPriceTooltip() {
        const { isPriceTooltipVisible, isValidationTooltipVisible } = this.state;

        return (
            <Tooltip
                className={cnOrderForm('PriceTooltip')}
                autoclosable
                visible={isPriceTooltipVisible && !isValidationTooltipVisible}
                theme=\\"normal\\"
                anchor={this.fieldToRefMap.orderPrice.ref?.current}
                onClick={this.closePriceTooltip}
                onClose={this.closePriceTooltip}
                onOutsideClick={this.closePriceTooltip}
            >
                <Text>Укажите бюджет</Text>
            </Tooltip>
        );
    }

    protected renderTitleWithDescriptionControls(formProps: IOrderFormRenderProps) {
        const {
            enableSuggestRubrics,
            filterSuggestResults,
            oldInputsVariant,
            withoutTitleInput,
            values,
            withClearerView,
        } = formProps;
        const suggestRubricId = values.rubric.specialization || values.rubric.category;

        const { placeholder, rubricsSearchQuery } = this.state;

        return (
            <>
                {this.props.isWorkerOrder && values.phone && (
                    <FormControl
                        theme={FormControlThemes.Normal}
                        label={oldInputsVariant === '1' ? 'Контакты' : undefined}
                        gap=\\"l\\"
                    >
                        <TextInput
                            name=\\"customerPhone\\"
                            text={values.phone + (values.customerName ? \` · \${values.customerName}\` : '')}
                            logNode={orderFormLogNodes.phone}
                            disabled
                        />
                    </FormControl>
                )}
                <div ref={this.fieldToRefMap.title.ref}>
                    <FormControl
                        theme={FormControlThemes.Normal}
                        label={oldInputsVariant === '1' ? 'Что нужно сделать' : undefined}
                        noGap
                    >
                        {withoutTitleInput ? undefined : (
                            <OrderTitleSuggestField
                                name=\\"title\\"
                                className={cnTestOrderForm('Title')}
                                placeholder={placeholder?.title || 'Короткое название задачи'}
                                withCapitalizedValue
                                rubricId={enableSuggestRubrics ? suggestRubricId : undefined}
                                onChange={this.onTitleSuggestChange}
                                onRubricChange={this.createOnTitleSuggestRubricChange(formProps)}
                                filterByRubric={Boolean(filterSuggestResults)}
                                focusOnInit={this.focusOnInit && !rubricsSearchQuery}
                                hideValidationError
                            />
                        )}
                    </FormControl>
                </div>
                <div ref={this.fieldToRefMap.description.ref}>
                    <FormControl
                        theme={FormControlThemes.Normal}
                        label={oldInputsVariant === '1' ? 'Описания и пожелания' : undefined}
                        gap={this.textAreaControlGap}
                        className={cnOrderForm('DescriptionFormControl', { withClearerView })}
                    >
                        {this.renderTextArea(formProps)}
                    </FormControl>
                </div>
            </>
        );
    }

    protected renderTextArea(formProps: IOrderFormRenderProps) {
        const { descriptionPlaceholder } = formProps;
        const { placeholder, rubricsSearchQuery } = this.state;

        return (
            <TextAreaAutosizeField
                name=\\"description\\"
                rows={this.props.descriptionRows}
                className={
                    cnOrderForm('Description', { rows: this.props.descriptionRows }, [cnTestOrderForm('Description')])
                }
                placeholder={
                    placeholder?.description ?
                        placeholder.description :
                        descriptionPlaceholder
                }
                logNode={orderFormLogNodes.description}
                hideValidationMessage
                focusOnInit={this.focusOnInit && Boolean(rubricsSearchQuery)}
                onFocus={this.showDescriptionTooltip}
                onBlur={this.hideDescriptionTooltip}
                onChangeCb={this.onDescriptionSuggestChange(formProps)}
            />
        );
    }

    protected renderSubmitButton(formProps: IOrderFormRenderProps) {
        const { errors, submitButtonText } = formProps;

        return (
            <Button
                className={cnOrderForm('SubmitButton')}
                type=\\"submit\\"
                onClick={this.createOnSubmitClick(errors, formProps)}
                theme=\\"action\\"
                logNode={orderFormLogNodes.submit}
                width={this.submitButtonWidth}
            >
                {submitButtonText}
            </Button>
        );
    }

    protected renderUnpublishButton(isUnpublishActionButton = false) {
        const { orderId } = this.props;

        if (!orderId) return;

        return (
            <UnpublishOrderContainer
                orderId={orderId}
                isButton={isUnpublishActionButton}
            />
        );
    }

    protected renderContactsModal(formProps: IOrderFormRenderProps) {
        const {
            handleSubmit,
            isUserAuthorized,
            isUserCallCenterOperator,
            trustedPhones,
            valid,
            form,
            values,
            shouldProvideUserPhone,
            showAddPhoneButton,
        } = formProps;
        const { props } = this;

        if (!isUserAuthorized || isUserCallCenterOperator) {
            return (
                <>
                    <OrderFormContactsModal
                        visible={this.state.isContactsModalVisible}
                        isModalFullScreen={this.isContactsModalFullscreen}
                        isUserAuthorized={isUserAuthorized}
                        isUserCallCenterOperator={isUserCallCenterOperator}
                        retpath={props.retpath}
                        onSubmit={handleSubmit}
                        onPhoneVerificationSubmit={this.onPhoneVerificationSubmit(formProps, true)}
                        onClose={this.createCloseContactsModal(formProps)}
                        phone={values.phone}
                        phoneId={values.phoneId}
                        trustedPhones={trustedPhones}
                        isValid={valid}
                        changeFieldValue={form.change}
                        hideEmailForAnonymous={props.hideEmailForAnonymous}
                    />
                </>
            );
        }

        if (shouldProvideUserPhone || showAddPhoneButton) {
            return (
                <PhoneVerificationModal
                    phone={values.phone}
                    onClose={this.createCloseContactsModal(formProps)}
                    onSubmit={this.onPhoneVerificationSubmit(formProps, this.state.needSubmit)}
                    phoneStepTitle=\\"Смс-уведомления об откликах\\"
                    description=\\"Добавьте номер телефона, чтобы быстро получать смс-уведомления о&nbsp;новых откликах на&nbsp;заказ. Без спама\\"
                    visible={this.state.isContactsModalVisible}
                    fullScreen={this.isContactsModalFullscreen}
                />
            );
        }
    }

    protected renderSimilarOccupationOrderModal(formProps: IOrderFormRenderProps) {
        const similarOccupationOrder = this.getSimilarOccupationOrder(formProps);

        return similarOccupationOrder ? (
            <OrderFormSimilarOrderContainer
                visible={this.state.isSimilarOrderVisible}
                orderId={similarOccupationOrder?.id}
                orderTitle={similarOccupationOrder.title}
                onClose={this.closeSimilarOrder}
                onCreateOrderClick={this.createCloseSimilarOccupationOrderModal(similarOccupationOrder, formProps)}
            />
        ) : null;
    }

    protected renderConfirmedOrder() {
        return this.props.withConfirmedOrder && this.props.onCloseConfirmedOrder ? (
            <ConfirmedOrderContainer
                onClose={this.props.onCloseConfirmedOrder}
                onNewOrderClick={this.props.onCloseConfirmedOrder}
            />
        ) : null;
    }

    @boundMethod
    private onTitleSuggestChange(value: string) {
        this.setState({ rubricsSearchQuery: value });
    }

    @boundMethod
    private onDescriptionSuggestChange(formProps: IOrderFormRenderProps) {
        return (value: string) => {
            if (formProps.values.rubric.specialization === Specializations.InternetMarketer) {
                this.setState({ rubricsSearchQuery: value });
            } else if (this.state.rubricsSearchQuery !== formProps.values.title) {
                this.setState({ rubricsSearchQuery: undefined });
            }
        };
    }

    @boundMethod
    protected createOnSubmitClick(errors: AnyObject, formProps: IOrderFormRenderProps) {
        const similarOccupationOrder = this.getSimilarOccupationOrder(formProps);

        if (similarOccupationOrder && similarOccupationOrder.rubrics[0] !== this.state.verifiedSimilarOrderOccupation) {
            return (event?: React.MouseEvent): boolean => {
                event?.preventDefault();
                this.openSimilarOrder();

                return false;
            };
        }

        if (formProps.withHidePhonesFromDescription) {
            const phoneInDescription = this.findUntrustedPhoneInDescription(formProps);

            if (phoneInDescription) {
                return (event?: React.MouseEvent): boolean => {
                    event?.preventDefault();

                    return this.linkPhoneFromDescription(phoneInDescription, formProps);
                };
            }
        }

        if (!isEmpty(errors)) {
            return (event?: React.MouseEvent): boolean => {
                event?.preventDefault();

                const contactsModalFieldNames: string[] = this.getContactsModalFieldNames();
                const firstInvalidNonContactField = Object.keys(errors)
                    .find(fieldName => !contactsModalFieldNames.includes(fieldName));

                if (!firstInvalidNonContactField) {
                    this.showContactsModal(true);
                } else {
                    this.setState({
                        validatingFieldName: firstInvalidNonContactField,
                        validationTooltipOptions: this.fieldToRefMap[firstInvalidNonContactField],
                        isValidationTooltipVisible: true,
                        isPriceTooltipVisible: false,
                    });
                }

                return false;
            };
        }

        return () => true;
    }

    @boundMethod
    private closeValidationTooltip() {
        this.setState({ isValidationTooltipVisible: false });
    }

    @boundMethod
    protected openPriceTooltip() {
        this.setState({ isPriceTooltipVisible: true, isDescriptionTooltipVisible: false });
    }

    @boundMethod
    private closePriceTooltip() {
        this.setState({ isPriceTooltipVisible: false });
    }

    @boundMethod
    private showContactsModal(needSubmit: boolean) {
        this.setState({
            isContactsModalVisible: true,
            needSubmit,
        });
        this.props.onInternalModalToggle?.(true);
    }

    @boundMethod
    protected createCloseContactsModal(formProps: IOrderFormRenderProps) {
        const { onInternalModalToggle } = this.props;
        const { form } = formProps;

        return () => {
            this.setState({ isContactsModalVisible: false });

            onInternalModalToggle?.(false);

            form.change('phone', undefined);
        };
    }

    @boundMethod
    protected createCloseSimilarOccupationOrderModal(order: IOrder, formProps: IOrderFormRenderProps) {
        return () => {
            this.setState({
                verifiedSimilarOrderOccupation: order.rubrics[0],
                isSimilarOrderVisible: false,
            }, () => {
                if (formProps.withHidePhonesFromDescription) {
                    const phoneInDescription = this.findUntrustedPhoneInDescription(formProps);

                    if (phoneInDescription) {
                        this.linkPhoneFromDescription(phoneInDescription, formProps);

                        return;
                    }
                }

                return formProps.form.submit();
            });

            const { onInternalModalToggle } = this.props;

            onInternalModalToggle?.(false);
        };
    }

    private findUntrustedPhoneInDescription(formProps: IOrderFormRenderProps): string | undefined {
        const { phonesList } = formProps;

        const rawPhoneInDescription = findPhonesInStr(formProps.values.description)[0];
        const phoneInDescription = rawPhoneInDescription ?
            addPlusToPhone(replaceEight(cleanPhone(rawPhoneInDescription))) :
            undefined;
        const isPhoneTrusted = phonesList.find(phoneData => phoneData.text === phoneInDescription);

        return isPhoneTrusted ? undefined : phoneInDescription;
    }

    private linkPhoneFromDescription(phone: string, formProps: IOrderFormRenderProps) {
        formProps.form.change('phone', phone);

        this.showContactsModal(true);

        return true;
    }

    @boundMethod
    private openSimilarOrder() {
        this.setState({
            isSimilarOrderVisible: true,
            isValidationTooltipVisible: false,
            isPriceTooltipVisible: false,
            isDescriptionTooltipVisible: false,
        });
        this.props.onInternalModalToggle?.(true);
    }

    @boundMethod
    protected closeSimilarOrder() {
        this.setState({ isSimilarOrderVisible: false });

        const { onInternalModalToggle } = this.props;

        onInternalModalToggle?.(false);
    }

    @boundMethod
    protected onUploadingImagesCountChange(uploadingImagesCount: number) {
        this.setState({ uploadingImagesCount });
    }

    @boundMethod
    rubricsSuggestQuery(rubricId: string | undefined, formProps: IOrderFormRenderProps) {
        const { searchRubrics } = this.props;
        const { rubricsSearchQuery, isLoadingRubrics } = this.state;

        if (isLoadingRubrics) {
            return;
        }

        this.setState({ isLoadingRubrics: true });

        return searchRubrics(rubricsSearchQuery, rubricId)
            .then(result => this.debouncedHandleSuggestResponse(
                result, undefined, Boolean(rubricId), formProps, rubricId,
            ));
    }

    private debouncedHandleSuggestResponse = debounce(this.handleSuggestResponse, REQUEST_DELAY);

    @boundMethod
    private handleSuggestResponse(
        response: ISearchRubricsResponse,
        titleSuggestRubric: string | undefined,
        ignoreRubricChanges: boolean,
        formProps: IOrderFormRenderProps,
        fallbackRubricId?: string,
    ) {
        const {
            descriptionPlaceholder,
            form,
            sendRubricsSuggested,
            specializationsById,
            specializationsBySeoId,
        } = formProps;

        const wasRubricSelectByUser = this.selectedByUser.rubric;

        if (!titleSuggestRubric) { // если последний вызов был из search_rubrics а не садджеста.
            titleSuggestRubric = this.state.titleSuggestRubric || fallbackRubricId;
        }

        if (isEmpty(response) && !titleSuggestRubric) {
            this.setState({ isLoadingRubrics: false });

            if (formProps.values.title) {
                sendRubricsSuggested?.(false);
            }

            return;
        }

        const { rubrics, placeholder, address, orderCreationTooltip } = response;
        const formattedPlaceholder = {
            title: \`Например, \${(placeholder?.title || DEFAULT_PLACEHOLDERS.title).toLowerCase()}\`,
            description: (placeholder?.description || descriptionPlaceholder),
        };

        let areRubricsChanged: boolean;
        let occupationId: string | undefined;
        let specializationId: string | undefined;

        if (!ignoreRubricChanges && rubrics) {
            occupationId = rubrics.occupationId;
            specializationId = rubrics.specializationId;

            if (rubrics) {
                formProps.sendRubricsSuggested?.(true, rubrics.occupationId, rubrics.specializationId);
            } else {
                formProps.sendRubricsSuggested?.(false);
            }
        }

        if (!specializationId && titleSuggestRubric) {
            const specializationInfo = specializationsBySeoId[titleSuggestRubric] ||
                specializationsById[titleSuggestRubric];

            if (specializationInfo?.parentId) {
                occupationId = specializationInfo.parentId;
                specializationId = specializationInfo.id;
            }
        }

        if (!occupationId) {
            areRubricsChanged = false;
        } else {
            const { category, specialization } = formProps.values.rubric;
            const isSameResponse = category === occupationId && specialization === specializationId;

            areRubricsChanged = !isSameResponse;
        }

        const updatesOnRubricChanges = () => {
            this.updateAddressTypeOnRubricChange(specializationId || occupationId, formProps);
            this.updateAddressesFromRubricsSuggest(address, formProps);
            this.updatePriceOnRubricChange(rubrics, formProps);
        };

        if (!areRubricsChanged || wasRubricSelectByUser) {
            // Если никакие рубрики не сматчились по запросу или сматченные по запросу рубрики совпадают с теми,
            // что уже установлены, то просто подставляем плэйсхолдеры и адреса безо всяких задержек
            this.setState({
                placeholder: formattedPlaceholder,
                orderCreationTooltip,
                isLoadingRubrics: false,
            });

            updatesOnRubricChanges();
        } else {
            if (this.timeout) {
                window.clearTimeout(this.timeout);
                this.timeout = null;
            }

            this.timeout = window.setTimeout(() => {
                this.setState({
                    orderCreationTooltip,
                    isLoadingRubrics: false,
                    placeholder: formattedPlaceholder,
                    titleSuggestRubric: undefined,
                });

                if (occupationId && specializationId) {
                    form.change('rubric', {
                        category: occupationId,
                        specialization: specializationId,
                    });
                }

                updatesOnRubricChanges();
            }, ANSWER_DELAY);
        }
    }

    private updateAddressesFromRubricsSuggest(address: IOrderAddress | undefined, formProps: IOrderFormRenderProps) {
        const { form, values } = formProps;
        const { addressSuggestGeoId } = this.state;

        if (!address?.name || address.geoid === addressSuggestGeoId) {
            return;
        }

        this.setState({
            addressSuggestGeoId: address.geoid,
        });

        if (values.orderAddressType === OrderAddressType.AtCustomer) {
            if (!values.orderAddressTouched) {
                this.setState({ preventDeviceGeoAutoDetection: true });

                form.change('orderAddress', address);
            }

            form.change('orderDistrict', address);
        } else if (values.orderAddressType === OrderAddressType.AtWorker) {
            this.setState({ preventDeviceGeoAutoDetection: true });
            form.change('orderAddress', address);

            !values.orderAddressTouched && form.change('orderDistrict', address);
        }
    }

    @boundMethod
    private createOnTitleSuggestRubricChange(formProps: IOrderFormRenderProps) {
        return (rubricId?: string) => {
            this.setState({ titleSuggestRubric: rubricId });

            const wasRubricSelectByUser = this.selectedByUser.rubric;

            if (!wasRubricSelectByUser) {
                this.debouncedHandleSuggestResponse({}, rubricId, false, formProps);
            }
        };
    }

    private updateAddressTypeOnRubricChange(rubricId: string | undefined, formProps: IOrderFormRenderProps): void {
        const {
            isExistedOrder,
            specializationsMap,
            form,
            values,
        } = formProps;

        if (isExistedOrder) {
            return;
        }

        rubricId && updateAddressTypeOnRubricChange({
            rubricId,
            currentAddressType: values.orderAddressType,
            isAddressTouched: Boolean(this.selectedByUser.orderAddress),
            isAddressTypeTouched: Boolean(this.selectedByUser.orderAddressType),
            specializationsMap,
            changeAddressType: (addressType: OrderAddressType) => form.change('orderAddressType', addressType),
        });
    }

    @boundMethod
    protected createOnRubricChange(formProps: IOrderFormRenderProps) {
        return (rubricId: string) => {
            this.updateAddressTypeOnRubricChange(rubricId, formProps);
            this.handleFieldSelectByUser('rubric');
            this.onRubricsSuggestChange(rubricId, formProps);
        };
    }

    private onRubricsSuggestChange(rubricId: string, formProps: IOrderFormRenderProps) {
        rubricId && this.debouncedRubricsSuggestQuery(rubricId, formProps);
    }

    private updatePriceOnRubricChange(
        rubrics: ISearchRubricsResponse['rubrics'],
        formProps: IOrderFormRenderProps,
    ): void {
        const {
            isExistedOrder,
            withPriceSuggest,
            form,
            sendPriceSuggested,
        } = formProps;

        if (!rubrics || isExistedOrder || !withPriceSuggest || !isPriceKeyExist(withPriceSuggest)) {
            return;
        }

        const { suggestPrice, occupationId, specializationId } = rubrics;

        if (!suggestPrice) {
            sendPriceSuggested?.(false, occupationId, specializationId);

            return;
        }

        form.change('orderPriceMeasure', suggestPrice.measure);
        form.change('orderPrice', suggestPrice[withPriceSuggest]);
        this.openPriceTooltip();

        sendPriceSuggested?.(true, occupationId, specializationId);
    }

    private getContactsModalFieldNames(): Array<keyof IOrderFormValues> {
        const {
            isUserCallCenterOperator,
            isUserAuthorized,
            shouldProvideUserPhone,
            hideEmailForAnonymous,
        } = this.props;

        if (!isUserAuthorized) {
            return hideEmailForAnonymous ?
                ['customerName', 'phone'] :
                ['customerName', 'customerEmail', 'phone'];
        }

        if (isUserCallCenterOperator) {
            return ['customerName', 'phone'];
        }

        return shouldProvideUserPhone ?
            ['customerEmail', 'phone'] :
            ['customerEmail'];
    }

    @boundMethod
    protected createOnFormMounted(formProps: IOrderFormRenderProps) {
        return () => {
            const initialRubric = formProps.initialValues?.rubric;

            this.debouncedRubricsSuggestQuery(initialRubric?.specialization, formProps);
        };
    }

    @boundMethod
    protected onFormStateChange(
        state: FormState<IOrderFormValues>,
        formProps: IOrderFormRenderProps,
    ) {
        const { specializationsById, form } = formProps;
        const { values } = state;
        const { isFormMounted, rubricsSearchQuery } = this.state;
        const isRemoteAllowed = Boolean((specializationsById[values.rubric.specialization] || {}).remotely);

        if (!isFormMounted) {
            return;
        }

        if (!isRemoteAllowed && values.orderAddressType === OrderAddressType.Remote) {
            form.change('orderAddressType', OrderAddressType.AtCustomer);
        }

        if (rubricsSearchQuery !== values.title) {
            this.debouncedRubricsSuggestQuery(undefined, formProps);
        }
    }

    @boundMethod
    protected onPhoneVerificationSubmit(formProps: IOrderFormRenderProps, needSubmit: boolean) {
        const { form } = formProps;

        return (phoneId: string) => {
            form.change('phoneId', phoneId);

            needSubmit && form.submit();
        };
    }

    @boundMethod
    protected onAddPhoneClick() {
        return () => this.showContactsModal(false);
    }

    protected renderAddPhoneBlock(formProps: IOrderFormRenderProps, gapBottom: Gaps) {
        const { showAddPhoneButton, email } = formProps;

        if (!showAddPhoneButton || this.props.isWorkerOrder) return;

        return (
            <OrderFormAddPhone
                email={email}
                gapBottom={gapBottom}
                openPhoneVerificationModal={this.onAddPhoneClick()}
            />
        );
    }

    private getSimilarOccupationOrder(formProps: IOrderFormRenderProps): IOrder | undefined {
        return formProps.sameOccupationRecentOrdersMap ?
            formProps.sameOccupationRecentOrdersMap[formProps.values.rubric.category] :
            undefined;
    }
}

import * as React from 'react';
import { IClassNameProps } from '@bem-react/core';

import { ICategoryPlaceholder, ISearchRubricsResponse } from '../../../api/internal/interfaces/rubrics';
import { ITextSizes } from '../../../features/ui-kit/components/Text/Text';
import { FileModel, IRubric } from '../../../models';
import {
    IOrder,
    IOrderAddress,
    IOrderDateRange,
    IOrderId,
    IOrderNotificationsAgreement,
    OrderAddressType,
    OrderDateType,
    OrderOriginType,
    OrderPriceType,
    OrderStatus,
    OrderTimeOfDay,
} from '../../../models/order';
import { IPaymentType } from '../../../models/payments';
import { PriceMeasure } from '../../../models/price';
import { IWorkerId } from '../../../models/worker';
import { IBaseFormProps, IBaseFormRenderProps } from '../../Form/Form';

export interface IOrderFormRubricValue {
    category: string;
    specialization: string;
}

export interface IOrderFormValues {
    paymentType?: IPaymentType;
    title: string;
    rubric: IOrderFormRubricValue;
    services?: string[];
    description: string;
    docs?: FileModel[];
    phoneId?: string;
    phone?: string;
    showAddPhoneButton?: boolean;
    email?: string | undefined;
    customerName: string;
    withCustomerName?: boolean;
    customerEmail: string | null;

    orderAddress?: IOrderAddress;
    orderAddressType: OrderAddressType;
    orderAddressTouched?: boolean;
    orderDistrict?: IOrderAddress;

    orderDate?: Date;
    orderDateType: OrderDateType;
    orderDateTime?: OrderTimeOfDay;
    orderDateRange?: IOrderDateRange;

    orderPrice?: number;
    orderPriceType: OrderPriceType;
    orderPriceMeasure: PriceMeasure;

    origin: OrderOriginType;

    showCustomerPhone: boolean;
    showPhoneForInvitedWorkers: boolean;

    searchable: boolean;
    suggestToWorkers: IWorkerId[];
    isUserCallCenterOperator?: boolean;
    isUserAuthorized?: boolean;
    isExistedOrder?: boolean;

    passDescriptionValidation?: boolean;
    passEmailValidation?: boolean;
    isWorkerOrder?: boolean;
    shouldProvideUserPhone?: boolean;

    notifications?: IOrderNotificationsAgreement;
}
export type IOrderFormKeys = keyof IOrderFormValues;

export interface IOrderFormOwnProps extends IClassNameProps {
    isLoading?: boolean;
    isExistedOrder?: boolean;

    titleSize?: ITextSizes;
    titleLineSize?: ITextSizes;
    descriptionRows?: number;
    phonesList: Array<{ val: string, text: string }>;
    customerPhone?: string;
    customerName?: string;
    phoneId?: string;
    formTitle: string;
    submitButtonText: string;
    descriptionPlaceholder: string;
    retpath: string;
    rubricsSearchQuery?: string;
    /**
     * Скрывать поле для ввода email в форме оставления контактов при создании заказа незалогиненным пользователем.
     * Нужно для эксперимента \`hide_create_order_email_for_anonymous\`
     */
    hideEmailForAnonymous?: boolean;
    withSticky?: boolean;
    noTitle?: boolean;
    noTitleField?: boolean;
    workerId?: IWorkerId;
    // при переписывании формы на FinalForm - убрать поле withCustomerNameField
    // сейчас оно прорастает в функцию валидации, для того, чтобы не валидировать поле имени заказчика для незалогинов
    // необходимо научиться правильно считать чиселку невалидных полей формы без этого костыля
    withCustomerNameField?: boolean;

    withConfirmedOrder?: boolean;
    withPaymentType?: boolean;

    openPhoneVerificationModal: () => void;
    onAdd?: (urls: FileModel[]) => void;
    disableSuggestOnTitle?: boolean;
    enableSuggestRubrics?: boolean;
    filterSuggestResults?: boolean;
    withPriceSuggest?: string;
    sendRubricsSuggested?: (isSuggested: boolean, occupationId?: string, specializationId?: string) => void,
    sendPriceSuggested?: (isSuggested: boolean, occupationId?: string, specializationId?: string) => void,

    isMultistep?: boolean;
    onSubmitButtonClick?: (result: SubmitButtonResults) => void;

    specializationsMap?: Record<string, IRubric>
    sameOccupationRecentOrdersMap?: Record<string, IOrder>
    isUserCallCenterOperator: boolean;
    priceMeasures?: PriceMeasure[];

    withStickySubmitButton?: boolean;
    withoutTitleInput?: boolean;
    withDisabledRubricField?: boolean;
    withNewValidationRules?: boolean;
    trustedPhones?: Record<string, string>;
    isUserAuthorized: boolean;
    specializationsById: Record<string, IRubric>;
    specializationsBySeoId: Record<string, IRubric>;
    withOldInputs: boolean;
    oldInputsVariant?: string;
    withOrderCreationTooltip?: boolean;
    orderCreationTooltipText?: string;
    isWorkerOrder?: boolean;
    hideCustomerPhone?: boolean;

    orderId?: IOrderId;
    orderStatus?: OrderStatus;

    onInternalModalToggle?: (toggle: boolean) => void;
    openModal?: (id: string) => void;
    phone?: string;
    showAddPhoneButton?: boolean;
    email?: string | undefined;
    showCustomerPhone?: boolean;
    onSubmitSuccess?: () => void;
    noCategoryField?: boolean;
    hasInvitedWorker?: boolean;
    shouldProvideUserPhone?: boolean;

    fetchLatestOrders?: () => void;

    onCloseConfirmedOrder?: () => void;
    withHidePhonesFromDescription?: boolean;

    isUserPlace?: boolean;
    isHomeFallbackAddress?: boolean;

    focusOnInit?: boolean;

    withNotifications?: boolean;
    withClearerView?: boolean;
    withPromoRefund?: boolean;
    withHypergeoOrders: boolean;
    isSearchPage?: boolean;
    onBack?: () => void;
    searchRubrics: (
        query: string | undefined,
        rubricId: string | undefined,
    ) => Promise<ISearchRubricsResponse>;
}

export const enum SubmitButtonResults {
    Create = 'created',
    Error = 'error',
    NextStep = 'next_step',
}

export interface IOrderFormValidationTooltipOptions {
    text?: string;
    ref?: React.RefObject<HTMLDivElement>,
    offset?: number
}

export interface IOrderFormState {
    isContactsModalVisible: boolean;
    isSimilarOrderVisible: boolean;
    verifiedSimilarOrderOccupation?: string;
    isValidationTooltipVisible: boolean;
    isPriceTooltipVisible: boolean;
    isDescriptionTooltipVisible: boolean;
    isDescriptionTooltipClosed: boolean;
    validatingFieldName?: string;
    validationTooltipOptions?: IOrderFormValidationTooltipOptions;
    fieldToRefMap?: Record<string, React.RefObject<unknown>>;
    uploadingImagesCount: number;
    titleSuggestRubric?: string;
    orderCreationTooltip?: any;
    placeholder?: ICategoryPlaceholder;
    addressSuggestGeoId?: number;
    isLoadingRubrics?: boolean;
    showValidationErrors: boolean;
    preventDeviceGeoAutoDetection?: boolean;
    isFormMounted?: boolean;
    needSubmit: boolean;
    rubricsSearchQuery?: string;
}

export type IOrderFormProps = IBaseFormProps<IOrderFormValues> & IOrderFormOwnProps;
export type IOrderFormRenderProps = IBaseFormRenderProps<IOrderFormProps>;

",
    },
    "line": 1318,
    "message": "\`redux\` import should occur before import of \`../../../api/internal/interfaces/rubrics\`",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/order",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 72,
    "endLine": 1320,
    "line": 1320,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 47,
    "endLine": 1321,
    "line": 1321,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 75,
    "endLine": 1322,
    "line": 1322,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 70,
    "endLine": 1323,
    "line": 1323,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 79,
    "endLine": 1324,
    "line": 1324,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 89,
    "endLine": 1325,
    "line": 1325,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 47,
    "endLine": 1326,
    "line": 1326,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 18,
    "endColumn": 20,
    "endLine": 1346,
    "line": 1346,
    "message": "An empty interface is equivalent to \`{}\`.",
    "messageId": "noEmpty",
    "nodeType": "Identifier",
    "ruleId": "@typescript-eslint/no-empty-interface",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 40,
    "endLine": 1348,
    "line": 1348,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 40,
    "endLine": 1348,
    "line": 1348,
    "message": "\`react-scroll\` import should occur before import of \`../../../api/internal/interfaces/rubrics\`",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/order",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 69,
    "endLine": 1349,
    "line": 1349,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 69,
    "endLine": 1349,
    "line": 1349,
    "message": "\`connected-react-router\` import should occur before import of \`../../../api/internal/interfaces/rubrics\`",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/order",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 36,
    "endLine": 1350,
    "line": 1350,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 36,
    "endLine": 1350,
    "line": 1350,
    "message": "\`history\` import should occur before import of \`../../../api/internal/interfaces/rubrics\`",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/order",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 40,
    "endLine": 1351,
    "line": 1351,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 40,
    "endLine": 1351,
    "line": 1351,
    "message": "'lodash' should be listed in the project's dependencies. Run 'npm i -S lodash' to add it",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/no-extraneous-dependencies",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 40,
    "endLine": 1351,
    "line": 1351,
    "message": "\`lodash\` import should occur before import of \`../../../api/internal/interfaces/rubrics\`",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/order",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 35,
    "endLine": 1352,
    "line": 1352,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 35,
    "endLine": 1352,
    "line": 1352,
    "message": "\`redux-saga\` import should occur before import of \`../../../api/internal/interfaces/rubrics\`",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/order",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 100,
    "endLine": 1353,
    "line": 1353,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 100,
    "endLine": 1353,
    "line": 1353,
    "message": "\`redux-saga/effects\` import should occur before import of \`../../../api/internal/interfaces/rubrics\`",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/order",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 56,
    "endLine": 1354,
    "line": 1354,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 56,
    "endLine": 1354,
    "line": 1354,
    "message": "\`typesafe-actions\` import should occur before import of \`../../../api/internal/interfaces/rubrics\`",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/order",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 78,
    "endLine": 1356,
    "line": 1356,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 36,
    "endLine": 1361,
    "line": 1357,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 78,
    "endLine": 1362,
    "line": 1362,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 76,
    "endLine": 1363,
    "line": 1363,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 46,
    "endLine": 1364,
    "line": 1364,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 78,
    "endLine": 1365,
    "line": 1365,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 61,
    "endLine": 1366,
    "line": 1366,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 51,
    "endLine": 1367,
    "line": 1367,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 36,
    "endLine": 1376,
    "line": 1368,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 52,
    "endLine": 1377,
    "line": 1377,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 52,
    "endLine": 1378,
    "line": 1378,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 55,
    "endLine": 1379,
    "line": 1379,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 83,
    "endLine": 1380,
    "line": 1380,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 45,
    "endLine": 1381,
    "line": 1381,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 72,
    "endLine": 1382,
    "line": 1382,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 71,
    "endLine": 1383,
    "line": 1383,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 52,
    "endLine": 1384,
    "line": 1384,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 77,
    "endLine": 1385,
    "line": 1385,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 52,
    "endLine": 1386,
    "line": 1386,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 67,
    "endLine": 1387,
    "line": 1387,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 55,
    "endLine": 1388,
    "line": 1388,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 49,
    "endLine": 1389,
    "line": 1389,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 108,
    "endLine": 1390,
    "line": 1390,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 86,
    "endLine": 1391,
    "line": 1391,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 44,
    "endLine": 1393,
    "line": 1393,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 117,
    "endLine": 1394,
    "line": 1394,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 119,
    "endLine": 1395,
    "line": 1395,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 22,
    "endLine": 1405,
    "line": 1396,
    "message": "Import in body of module; reorder to top.",
    "nodeType": "ImportDeclaration",
    "ruleId": "import/first",
    "severity": 1,
  },
  Object {
    "column": 1,
    "endColumn": 13,
    "endLine": 1781,
    "fix": Object {
      "range": Array [
        63529,
        63541,
      ],
      "text": "                ",
    },
    "line": 1781,
    "message": "Expected indentation of 16 spaces but found 12.",
    "messageId": "wrongIndentation",
    "nodeType": "Identifier",
    "ruleId": "indent",
    "severity": 2,
  },
  Object {
    "column": 1,
    "endColumn": 1,
    "endLine": 2036,
    "fix": Object {
      "range": Array [
        72743,
        72745,
      ],
      "text": "",
    },
    "line": 2034,
    "message": "Too many blank lines at the end of file. Max of 0 allowed.",
    "messageId": "blankEndOfFile",
    "nodeType": "Program",
    "ruleId": "no-multiple-empty-lines",
    "severity": 2,
  },
]
`;
