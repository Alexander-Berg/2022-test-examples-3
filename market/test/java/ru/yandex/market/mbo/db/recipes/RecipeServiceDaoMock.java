package ru.yandex.market.mbo.db.recipes;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import ru.yandex.market.mbo.gwt.models.recipe.Recipe;
import ru.yandex.market.mbo.gwt.models.recipe.RecipeFilter;
import ru.yandex.market.mbo.gwt.models.recipe.RecipeSqlFilter;

@SuppressWarnings("checkstyle:MagicNumber")
public class RecipeServiceDaoMock extends RecipeServiceDao {

    static final long EXIST_PARAM_ID = 10L;
    static final long BOOLEAN_PARAM_ID = 20L;
    static final long NUMERIC_PARAM_ID = 30L;
    static final long EXIST_OPTION_ID1 = 100L;
    static final long EXIST_OPTION_ID2 = 200L;
    static final long EXIST_OPTION_ID3 = 300L;
    static final long HID = 1L;

    private List<Recipe> searchRecipes;
    private List<Recipe> navigationRecipes;

    public RecipeServiceDaoMock() {
        super(null, null, null);

        searchRecipes = new ArrayList<>();
        searchRecipes.add(generateRecipe(HID, 1L, "Name_1", "Header_1",
            true, false, false, false));
        searchRecipes.add(generateRecipe(HID, 2L, "Name_2", "Header_2",
            false, true, false, false));
        searchRecipes.add(generateRecipe(HID, 3L, "Name_3", "Header_3",
            false, false, true, false));
        searchRecipes.add(generateRecipe(HID, 4L, "Name_4", "Header_4",
            true, true, false, false));
        searchRecipes.add(generateRecipe(HID, 5L, "Name_5", "Header_5",
            true, false, true, false));
        searchRecipes.add(generateRecipe(HID, 6L, "Name_6", "Header_6",
            false, true, true, false));
        searchRecipes.add(generateRecipe(HID, 7L, "Name_7", "Header_7",
            true, true, true, false));
        searchRecipes.add(generateRecipe(HID, 8L, "Name_8", "Header_8",
            true, true, true, true));

        navigationRecipes = new ArrayList<>();
        navigationRecipes.add(generateRecipe(HID, 1L, "Name_1", "Header_1",
            true, false, false, false));
        navigationRecipes.add(generateRecipe(HID, 2L, "Name_2", "Header_2",
            false, true, false, false));
        navigationRecipes.add(generateRecipe(HID, 3L, "Name_3", "Header_3",
            false, false, true, false));
        navigationRecipes.add(generateRecipe(HID, 4L, "Name_4", "Header_4",
            true, true, false, false));
        navigationRecipes.add(generateRecipe(HID, 5L, "Name_5", "Header_5",
            true, false, true, false));
        navigationRecipes.add(generateRecipe(HID, 6L, "Name_6", "Header_6",
            false, true, true, false));
        navigationRecipes.add(generateRecipe(HID, 7L, "Name_7", "Header_7",
            true, true, true, false));

        // Используется для тестирования isUniqueName и isUniqueHeader, чтобы убедится,
        // что навигационные рецепты и поисковые не пересекаются
        navigationRecipes.add(generateRecipe(HID, 8L, "AlreadyExist", "Header_8",
            true, true, true, false));
        navigationRecipes.add(generateRecipe(HID, 9L, "Name_8", "AlreadyExist",
            true, true, true, false));
    }

    @SuppressWarnings("checkstyle:ParameterNumber")
    private static Recipe generateRecipe(Long hid,
                                         Long id,
                                         String name,
                                         String header,
                                         boolean addBooleanFilter,
                                         boolean addNumericFilter,
                                         boolean addEnumFilter,
                                         boolean asAutoGenerated) {
        Recipe recipe = new Recipe();
        recipe.setHid(hid);
        recipe.setId(id);
        recipe.setName(name);
        recipe.setHeader(header);
        recipe.setNavigation(false);
        recipe.setAutoGenerated(asAutoGenerated);
        ArrayList<RecipeFilter> filters = new ArrayList<>();

        if (addBooleanFilter) {
            RecipeFilter filter = new RecipeFilter();
            filter.setParamId(BOOLEAN_PARAM_ID);
            filter.setBooleanValue(true);
            filters.add(filter);
        }

        if (addNumericFilter) {
            RecipeFilter filter = new RecipeFilter();
            filter.setParamId(NUMERIC_PARAM_ID);
            filter.setMinValue(new BigDecimal(575));
            filter.setMaxValue(new BigDecimal(757));
            filters.add(filter);
        }

        if (addEnumFilter) {
            RecipeFilter filter = new RecipeFilter();
            filter.setParamId(EXIST_PARAM_ID);
            filter.setValueIds(Arrays.asList(EXIST_OPTION_ID1, EXIST_OPTION_ID2, EXIST_OPTION_ID3));
            filters.add(filter);
        }

        recipe.setFilters(filters);
        return recipe;
    }

    @Override
    public List<Recipe> getRecipesByParamId(Long id) {
        return id > 1 ? searchRecipes : Collections.emptyList();
    }

    @Override
    public int getSearchRecipesCount(RecipeSqlFilter filter) {
        if (filter.getParamId() > 0L) {
            int count = 0;
            for (Recipe recipe : searchRecipes) {
                count += recipe.getFilters().stream()
                    .filter(f -> f.getParamId().equals(filter.getParamId()))
                    .collect(Collectors.toList()).size();
            }
            return count;
        }
        return searchRecipes.size();
    }

    @Override
    public List<Recipe> getSearchRecipes(RecipeSqlFilter filter, int offset, int length,
                                         RecipeSqlFilter.Field sortField, boolean sortAsc, boolean nullFirst) {
        if (filter.isNotEmptyIds()) {
            return searchRecipes.stream().filter(r -> filter.getId().equals(r.getId()))
                .collect(Collectors.toList());
        }
        return searchRecipes;
    }

    @Override
    public List<Recipe> getNavigationRecipes(RecipeSqlFilter filter, int offset, int length,
                                             RecipeSqlFilter.Field sortField, boolean sortAsc) {
        return navigationRecipes.stream().filter(r -> filter.getId().equals(r.getId())).collect(Collectors.toList());
    }

    @Override
    public boolean isUniqueName(Long id, Long hid, String name, Boolean isNavigation) {
        if (isNavigation) {
            return navigationRecipes.stream()
                .filter(r -> r.getHid().equals(hid) && r.getName().equals(name)).count() == 0;
        } else {
            return searchRecipes.stream().filter(r -> r.getHid().equals(hid) && r.getName().equals(name)).count() == 0;
        }
    }

    @Override
    public boolean isUniqueHeader(Long id, String header, boolean published, Boolean isNavigation) {
        if (!published) {
            return true;
        }
        if (isNavigation) {
            return navigationRecipes.stream().filter(r -> r.getHeader().equals(header)).count() == 0;
        } else {
            return searchRecipes.stream().filter(r -> r.getHeader().equals(header)).count() == 0;
        }
    }

    private long generateId(Boolean isNavigation) {
        long maxValue = 0;

        List<Recipe> recipes = new ArrayList<>();
        if (isNavigation) {
            recipes.addAll(navigationRecipes);
        } else {
            recipes.addAll(searchRecipes);
        }
        for (Recipe recipe : recipes) {
            maxValue = Math.max(maxValue, recipe.getId());
        }
        return maxValue + 1;
    }

    @Override
    public boolean saveRecipe(Recipe recipe) {
        if (recipe.getId() == 0L) {
            recipe.setId(generateId(recipe.isNavigation()));
        }

        if (recipe.isNavigation()) {
            navigationRecipes = navigationRecipes.stream().filter(r -> r.getId() != recipe.getId())
                .collect(Collectors.toList());
            navigationRecipes.add(recipe);
        } else {
            searchRecipes = searchRecipes.stream().filter(r -> r.getId() != recipe.getId())
                .collect(Collectors.toList());
            searchRecipes.add(recipe);
        }
        return true;
    }

    @Override
    public boolean deleteRecipes(Long uid, List<Long> recipesIds) {
        return true;
    }

    @Override
    public List<Recipe> getRecipesByParamAndOptionIds(Long paramId, List<Long> optionIds) {
        return new ArrayList<>();
    }

}
