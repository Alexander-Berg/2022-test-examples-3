package ru.yandex.market.pricingmgmt.service.promo.validators

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertDoesNotThrow
import org.junit.jupiter.api.assertThrows
import org.mockito.Mockito.anyCollection
import org.mockito.Mockito.doReturn
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.mock.mockito.MockBean
import ru.yandex.market.pricingmgmt.AbstractFunctionalTest
import ru.yandex.market.pricingmgmt.exception.ExceptionCode
import ru.yandex.market.pricingmgmt.exception.ValidationException
import ru.yandex.market.pricingmgmt.model.postgres.Assortment
import ru.yandex.market.pricingmgmt.model.postgres.Warehouse
import ru.yandex.market.pricingmgmt.model.promo.Compensation
import ru.yandex.market.pricingmgmt.model.promo.CompensationReceiveMethod
import ru.yandex.market.pricingmgmt.model.promo.Promo
import ru.yandex.market.pricingmgmt.model.promo.PromoBudgetOwner
import ru.yandex.market.pricingmgmt.model.promo.PromoKind
import ru.yandex.market.pricingmgmt.model.promo.PromoMechanicsType
import ru.yandex.market.pricingmgmt.model.promo.PromoPurpose
import ru.yandex.market.pricingmgmt.model.promo.PromoStatus
import ru.yandex.market.pricingmgmt.model.promo.SupplierType
import ru.yandex.market.pricingmgmt.model.promo.mechanics.CheapestAsGift
import ru.yandex.market.pricingmgmt.model.promo.mechanics.CompleteSetKind
import ru.yandex.market.pricingmgmt.repository.postgres.AssortmentRepository
import ru.yandex.market.pricingmgmt.repository.postgres.PromoWarehouseRepository
import ru.yandex.market.pricingmgmt.service.ManagerService
import java.time.OffsetDateTime
import java.util.*

class CreatePromoValidatorTest : AbstractFunctionalTest() {

    @Autowired
    private val createPromoValidator: CreatePromoValidator? = null

    @MockBean
    private val managerService: ManagerService? = null

    @MockBean
    private val assortmentRepository: AssortmentRepository? = null

    @MockBean
    private val promoWarehouseRepository: PromoWarehouseRepository? = null

    @Test
    fun testValidatePromo_validationIsOk() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.startDate = OffsetDateTime.now().toEpochSecond()
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)
        promo.landingUrlAutogenerated = true
        promo.rulesUrlAutogenerated = true
        promo.mskusRestriction = listOf(123L)

        doReturn(true).`when`(managerService)?.isUserMarkom("catManager")
        doReturn(true).`when`(managerService)?.isUserTrade("tradeManager")
        doReturn(HashSet(listOf(123L))).`when`(assortmentRepository)?.findExistingMskus(anyCollection())

        assertDoesNotThrow { createPromoValidator?.validate(promo) }
    }

    @Test
    fun testValidatePromo_unknownMechanicsType_throwsException() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.mechanicsType = PromoMechanicsType.UNKNOWN
        promo.startDate = OffsetDateTime.now().toEpochSecond()
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)

        val e = assertThrows<ValidationException> { createPromoValidator?.validate(promo) }

        assertEquals(ExceptionCode.PROMO_MECHANICS_TYPE_UNKNOWN, e.code)
        assertEquals("Тип механики не распознан", e.message)
        assertEquals(listOf("mechanicsType"), e.errorFields)
    }

    @Test
    fun testValidatePromo_wrongDateTime_throwsException() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)

        val e = assertThrows<ValidationException> { createPromoValidator?.validate(promo) }

        assertEquals(ExceptionCode.PROMO_START_DATE_NULL, e.code)
        assertEquals("Не указана дата и время старта промо", e.message)
        assertEquals(listOf("startDate"), e.errorFields)
    }

    @Test
    fun testValidatePromo_wrongStatus_throwsException() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.startDate = OffsetDateTime.now().toEpochSecond()
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.status = PromoStatus.UNKNOWN
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)

        val e = assertThrows<ValidationException> { createPromoValidator?.validate(promo) }

        assertEquals(ExceptionCode.PROMO_FIELD_VALUE_INVALID, e.code)
        assertEquals("Значение поля \"Статус\" не распознано", e.message)
        assertEquals(listOf("status"), e.errorFields)
    }

    @Test
    fun testValidatePromo_wrongField_throwsException() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.startDate = OffsetDateTime.now().toEpochSecond()
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)
        promo.compensationSource = Compensation.UNKNOWN

        val e = assertThrows<ValidationException> { createPromoValidator?.validate(promo) }

        assertEquals(ExceptionCode.PROMO_FIELD_VALUE_INVALID, e.code)
        assertEquals("Значение поля \"Источник компенсации\" не распознано", e.message)
        assertEquals(listOf("compensationSource"), e.errorFields)
    }

    @Test
    fun testValidatePromo_unknownCompensationReceiveMethod_throwsException() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.startDate = OffsetDateTime.now().toEpochSecond()
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)
        promo.compensationSource = Compensation.PARTNER
        promo.compensationReceiveMethods =
            listOf(CompensationReceiveMethod.WITHOUT_COMPENSATION, CompensationReceiveMethod.UNKNOWN)

        val e = assertThrows<ValidationException> { createPromoValidator?.validate(promo) }

        assertEquals(ExceptionCode.PROMO_FIELD_VALUE_INVALID, e.code)
        assertEquals("Значение поля \"Способы получения компенсации\" не распознано", e.message)
        assertEquals(listOf("compensationReceiveMethods"), e.errorFields)
    }

    @Test
    fun testValidatePromo_emptyCompensationReceiveMethod_throwsException() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.startDate = OffsetDateTime.now().toEpochSecond()
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)
        promo.landingUrlAutogenerated = true
        promo.rulesUrlAutogenerated = true
        promo.compensationSource = Compensation.PARTNER
        promo.compensationReceiveMethods = emptyList()

        val e = assertThrows<ValidationException> { createPromoValidator?.validate(promo) }

        assertEquals(ExceptionCode.PROMO_COMPENSATIONS_RECEIVE_METHODS_EMPTY, e.code)
        assertEquals("Не указаны способы получения компенсации при источнике компенсации \"Партнёр\"", e.message)
        assertEquals(listOf("compensationReceiveMethods"), e.errorFields)
    }

    @Test
    fun testValidatePromo_nullCompensationReceiveMethod_throwsException() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.startDate = OffsetDateTime.now().toEpochSecond()
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)
        promo.landingUrlAutogenerated = true
        promo.rulesUrlAutogenerated = true
        promo.compensationSource = Compensation.PARTNER
        promo.compensationReceiveMethods = listOf(CompensationReceiveMethod.WITHOUT_COMPENSATION, null)

        val e = assertThrows<ValidationException> { createPromoValidator?.validate(promo) }

        assertEquals(ExceptionCode.PROMO_FIELD_VALUE_INVALID, e.code)
        assertEquals("Поле \"Способы получения компенсации\" содержит пустое значение", e.message)
        assertEquals(listOf("compensationReceiveMethods"), e.errorFields)
    }

    @Test
    fun testValidatePromo_notNullCompensationReceiveMethod_isOk() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.startDate = OffsetDateTime.now().toEpochSecond()
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)
        promo.compensationSource = Compensation.PARTNER
        promo.compensationReceiveMethods = listOf(CompensationReceiveMethod.VENDOR_CABINET_OFF_INVOICE)
        promo.landingUrlAutogenerated = true
        promo.rulesUrlAutogenerated = true

        doReturn(listOf(Warehouse(1L, "w1"))).`when`(promoWarehouseRepository)?.getWarehouses(anyCollection())

        assertDoesNotThrow { createPromoValidator?.validate(promo) }
    }

    @Test
    fun testValidatePromo_unknownMsku_throwsException() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.startDate = OffsetDateTime.now().toEpochSecond()
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)
        promo.landingUrlAutogenerated = true
        promo.rulesUrlAutogenerated = true
        promo.mskusRestriction = listOf(123L, 124L)

        doReturn(true).`when`(managerService)?.isUserMarkom("catManager")
        doReturn(true).`when`(managerService)?.isUserTrade("tradeManager")

        doReturn(listOf(Assortment(msku = 123, title = "msku123"))).`when`(assortmentRepository)?.findByMskus(
            anyCollection()
        )
        doReturn(emptyList<Assortment>()).`when`(assortmentRepository)?.findByOutdatedMskus(anyCollection())
        doReturn(listOf(Warehouse(1L, "w1"))).`when`(promoWarehouseRepository)?.getWarehouses(anyCollection())

        val e = assertThrows<ValidationException> { createPromoValidator?.validate(promo) }

        assertEquals(ExceptionCode.PROMO_RESTRICTION_INTERNAL, e.code)
        assertEquals("MSKU не найдены: 124", e.message)
        assertEquals(listOf("mskusRestriction"), e.errorFields)
    }

    @Test
    fun testValidatePromo_unknownWarehouse_throwsException() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.startDate = OffsetDateTime.now().toEpochSecond()
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)
        promo.landingUrlAutogenerated = true
        promo.rulesUrlAutogenerated = true

        doReturn(true).`when`(managerService)?.isUserMarkom("catManager")
        doReturn(true).`when`(managerService)?.isUserTrade("tradeManager")

        doReturn(Collections.emptyList<Warehouse>()).`when`(promoWarehouseRepository)?.getWarehouses(anyCollection())

        val e = assertThrows<ValidationException> { createPromoValidator?.validate(promo) }

        assertEquals(ExceptionCode.PROMO_RESTRICTION_INTERNAL, e.code)
        assertEquals("Склады не найдены: 1", e.message)
        assertEquals(listOf("warehousesRestriction"), e.errorFields)
    }

    @Test
    fun testValidatePromo_PiPromoValidator_throwsException() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.startDate = OffsetDateTime.now().toEpochSecond()
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)
        promo.landingUrlAutogenerated = true
        promo.rulesUrlAutogenerated = true
        promo.mskusRestriction = listOf(123L)
        promo.piPublishDate = OffsetDateTime.now().toEpochSecond()
        promo.warehousesRestriction = null

        doReturn(true).`when`(managerService)?.isUserMarkom("catManager")
        doReturn(true).`when`(managerService)?.isUserTrade("tradeManager")
        doReturn(listOf(Assortment(msku = 123, title = "msku123"))).`when`(assortmentRepository)?.findByMskus(
            anyCollection()
        )
        doReturn(emptyList<Assortment>()).`when`(assortmentRepository)?.findByOutdatedMskus(anyCollection())

        val e = assertThrows<ValidationException> { createPromoValidator?.validate(promo) }

        assertEquals(ExceptionCode.PROMO_WAREHOUSES_EMPTY, e.code)
        assertEquals("Для механики \"Самый дешевый в подарок\" не указаны склады", e.message)
        assertEquals(listOf("warehousesRestriction"), e.errorFields)
    }

    @Test
    fun testValidatePromo_ParentPromoValidator_throwsException() {

        val promo = buildPromo()
        promo.promoId = "123"
        promo.startDate = OffsetDateTime.now().toEpochSecond()
        promo.endDate = OffsetDateTime.now().plusHours(1).toEpochSecond()
        promo.cheapestAsGift = CheapestAsGift(CompleteSetKind.SET_OF_3)
        promo.landingUrlAutogenerated = true
        promo.rulesUrlAutogenerated = true
        promo.mskusRestriction = listOf(123L)
        promo.promoKind = PromoKind.NATIONAL
        promo.parentPromoId = null

        doReturn(true).`when`(managerService)?.isUserMarkom("catManager")
        doReturn(true).`when`(managerService)?.isUserTrade("tradeManager")
        doReturn(listOf(Assortment(msku = 123, title = "msku123"))).`when`(assortmentRepository)?.findByMskus(
            anyCollection()
        )
        doReturn(emptyList<Assortment>()).`when`(assortmentRepository)?.findByOutdatedMskus(anyCollection())
        doReturn(listOf(Warehouse(1L, "w1"))).`when`(promoWarehouseRepository)?.getWarehouses(anyCollection())

        val e = assertThrows<ValidationException> { createPromoValidator?.validate(promo) }

        assertEquals(ExceptionCode.PROMO_PARENT_PROMO_NULL, e.code)
        assertEquals("Не указано родительское промо", e.message)
        assertEquals(listOf("parentPromoId"), e.errorFields)
    }

    private fun buildPromo(): Promo {
        return Promo(
            departments = listOf("department1", "department2"),
            promoKind = PromoKind.VENDOR,
            purpose = PromoPurpose.GMV_GENERATION,
            budgetOwner = PromoBudgetOwner.PRODUCT,
            supplierType = SupplierType.THIRD_PARTY,
            compensationSource = Compensation.PARTNER,
            status = PromoStatus.NEW,
            mechanicsType = PromoMechanicsType.CHEAPEST_AS_GIFT,
            tradeManager = "tradeManager",
            markom = "catManager",
            author = "authorLogin",
            compensationReceiveMethods = listOf(
                CompensationReceiveMethod.WITHOUT_COMPENSATION,
                CompensationReceiveMethod.VENDOR_CABINET_OFF_INVOICE
            ),
            warehousesRestriction = listOf(1L)
        )
    }
}
