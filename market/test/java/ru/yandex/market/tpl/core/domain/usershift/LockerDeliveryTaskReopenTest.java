package ru.yandex.market.tpl.core.domain.usershift;

import java.time.Clock;
import java.time.Instant;
import java.time.LocalDate;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import lombok.RequiredArgsConstructor;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.transaction.support.TransactionTemplate;

import ru.yandex.market.logistic.api.model.common.OrderStatusType;
import ru.yandex.market.tpl.api.model.order.OrderFlowStatus;
import ru.yandex.market.tpl.api.model.order.OrderPaymentType;
import ru.yandex.market.tpl.api.model.order.clientreturn.ClientReturnCreateDto;
import ru.yandex.market.tpl.api.model.order.locker.PartnerSubType;
import ru.yandex.market.tpl.api.model.task.OrderDeliveryTaskFailReasonType;
import ru.yandex.market.tpl.api.model.task.Source;
import ru.yandex.market.tpl.api.model.task.pickupPoint.LockerDeliverySubtaskStatus;
import ru.yandex.market.tpl.api.model.task.pickupPoint.LockerDeliveryTaskStatus;
import ru.yandex.market.tpl.core.domain.barcode_prefix.ReturnBarcodePrefixRepository;
import ru.yandex.market.tpl.core.domain.clientreturn.ClientReturnService;
import ru.yandex.market.tpl.core.domain.order.Order;
import ru.yandex.market.tpl.core.domain.order.OrderGenerateService;
import ru.yandex.market.tpl.core.domain.order.OrderManager;
import ru.yandex.market.tpl.core.domain.order.OrderRepository;
import ru.yandex.market.tpl.core.domain.order.address.AddressGenerator;
import ru.yandex.market.tpl.core.domain.partner.SortingCenter;
import ru.yandex.market.tpl.core.domain.partner.SortingCenterService;
import ru.yandex.market.tpl.core.domain.pickup.PickupPoint;
import ru.yandex.market.tpl.core.domain.pickup.PickupPointRepository;
import ru.yandex.market.tpl.core.domain.sc.OrderStatusUpdate;
import ru.yandex.market.tpl.core.domain.sc.ScManager;
import ru.yandex.market.tpl.core.domain.sc.model.ScOrder;
import ru.yandex.market.tpl.core.domain.sc.model.ScOrderRepository;
import ru.yandex.market.tpl.core.domain.shift.Shift;
import ru.yandex.market.tpl.core.domain.shift.TestUserHelper;
import ru.yandex.market.tpl.core.domain.user.User;
import ru.yandex.market.tpl.core.domain.usershift.commands.OrderDeliveryFailReason;
import ru.yandex.market.tpl.core.domain.usershift.commands.ScanRequest;
import ru.yandex.market.tpl.core.domain.usershift.commands.UserShiftCommand;
import ru.yandex.market.tpl.core.domain.usershift.location.GeoPoint;
import ru.yandex.market.tpl.core.domain.usershift.location.GeoPointGenerator;
import ru.yandex.market.tpl.core.test.TestDataFactory;
import ru.yandex.market.tpl.core.test.TplAbstractTest;

import static org.assertj.core.api.Assertions.assertThat;

@RequiredArgsConstructor
class LockerDeliveryTaskReopenTest extends TplAbstractTest {

    public static final String EXTERNAL_ORDER_ID_1 = "EXTERNAL_ORDER_ID_1";
    public static final String EXTERNAL_ORDER_ID_2 = "EXTERNAL_ORDER_ID_2";
    public static final String EXTERNAL_ORDER_ID_3 = "EXTERNAL_ORDER_ID_3";
    public static final String CLIENT_RETURN_EXTERNAL_ID_1 = "EXTERNAL_RETURN_ID_1";

    private final TestDataFactory testDataFactory;
    private final TestUserHelper testUserHelper;
    private final OrderGenerateService orderGenerateService;
    private final PickupPointRepository pickupPointRepository;
    private final OrderManager orderManager;
    private final UserShiftCommandService userShiftCommandService;
    private final UserShiftReassignManager userShiftReassignManager;
    private final UserShiftRepository userShiftRepository;
    private final OrderRepository orderRepository;
    private final Clock clock;
    private final SortingCenterService sortingCenterService;
    private final ScManager scManager;
    private final ScOrderRepository scOrderRepository;
    private final UserShiftManager userShiftManager;
    private final ClientReturnService clientReturnService;
    private final TransactionTemplate transactionTemplate;
    private final ReturnBarcodePrefixRepository barcodePrefixRepository;

    private User user;
    private SortingCenter sortingCenter;
    private Shift shift;
    private UserShift userShift;
    private PickupPoint pickupPointLocker;
    private PickupPoint pickupPointPvz;
    private String clientReturnBarcodeExternalCreated1;

    @BeforeEach
    void setup() {
        clientReturnBarcodeExternalCreated1 = barcodePrefixRepository.findBarcodePrefixByName(
                "CLIENT_RETURN_BARCODE_PREFIX_SF").getBarcodePrefix() + "3";
        user = testUserHelper.findOrCreateUser(1L);
        sortingCenter = sortingCenterService.findSortCenterForDs(239);
        shift = testUserHelper.findOrCreateOpenShiftForSc(LocalDate.now(clock),
                sortingCenter.getId());
        Long userShiftId = testDataFactory.createEmptyShift(shift.getId(), user);
        userShift = userShiftRepository.findByIdOrThrow(userShiftId);
        pickupPointLocker = pickupPointRepository.save(
                testDataFactory.createPickupPoint(PartnerSubType.LOCKER, 1L, 1L));
        pickupPointPvz = pickupPointRepository.save(
                testDataFactory.createPickupPoint(PartnerSubType.PVZ, 2L, 1L));
    }


    @Test
    void reopenLockerTask() {
        GeoPoint geoPoint = GeoPointGenerator.generateLonLat();

        Order order = getPickupOrder(EXTERNAL_ORDER_ID_1, pickupPointLocker, geoPoint);
        Order order2 = getPickupOrder(EXTERNAL_ORDER_ID_2, pickupPointLocker, geoPoint);

        transactionTemplate.execute(ts -> {
            var us = userShiftRepository.findById(userShift.getId()).orElseThrow();
            userShiftReassignManager.assign(us, order);
            userShiftReassignManager.assign(us, order2);
            return null;
        });


        userShiftCommandService.checkin(userShift.getUser(), new UserShiftCommand.CheckIn(userShift.getId()));
        userShiftCommandService.startShift(userShift.getUser(), new UserShiftCommand.Start(userShift.getId()));
        testUserHelper.finishPickupAtStartOfTheDay(userShift, false);

        LockerDeliveryTask lockerDeliveryTask = reloadTaskWithDependencies();

        assertThatFailSubtasksAndCancelTask();

        reopenTaskForOrder(order);

        checkAssignment(user, order);

        reopenTaskForOrder(order2);

        checkAssignment(user, order, order2);
    }

    @Test
    void testReassignLockerDeliveryTaskToAnotherCourierAndBack() {
        User user1 = user;
        User user2 = testUserHelper.findOrCreateUser(2L);
        Long userShiftId1 = userShift.getId();
        Long userShiftId2 = testDataFactory.createEmptyShift(shift.getId(), user2);
        var userShift1 = userShift;
        var userShift2 = userShiftRepository.findByIdOrThrow(userShiftId2);

        GeoPoint geoPoint = GeoPointGenerator.generateLonLat();
        GeoPoint geoPoint2 = GeoPointGenerator.generateLonLat();

        Order order = getPickupOrder(EXTERNAL_ORDER_ID_1, pickupPointLocker, geoPoint);
        Order order2 = getPickupOrder(EXTERNAL_ORDER_ID_2, pickupPointLocker, geoPoint);
        Order order3 = getPickupOrder(EXTERNAL_ORDER_ID_3, pickupPointLocker, geoPoint2);


        transactionTemplate.execute(ts -> {
            var us1 = userShiftRepository.findById(userShiftId1).orElseThrow();
            var us2 = userShiftRepository.findById(userShiftId2).orElseThrow();
            userShiftReassignManager.assign(us1, order);
            userShiftReassignManager.assign(us1, order2);
            userShiftReassignManager.assign(us2, order3);
            return null;
        });


        userShiftCommandService.checkin(userShift1.getUser(), new UserShiftCommand.CheckIn(userShift1.getId()));
        userShiftCommandService.startShift(userShift1.getUser(), new UserShiftCommand.Start(userShift1.getId()));
        testUserHelper.finishPickupAtStartOfTheDay(userShift1, true);

        userShiftCommandService.checkin(userShift2.getUser(), new UserShiftCommand.CheckIn(userShift2.getId()));
        userShiftCommandService.startShift(userShift2.getUser(), new UserShiftCommand.Start(userShift2.getId()));
        testUserHelper.finishPickupAtStartOfTheDay(userShift2, true);

        LockerDeliveryTask task1 = reloadTaskWithDependencies(userShift1);
        assertThat(task1.getSubtasks()).hasSize(2);

        LockerDeliveryTask task2 = reloadTaskWithDependencies(userShift2);
        assertThat(task2.getSubtasks()).hasSize(1);

        userShiftReassignManager.reassignOrders(Set.of(order.getId(), order2.getId()), Set.of(), Set.of(),
                user2.getId());
        assertThatFailSubtasksAndCancelTask();
        checkAssignment(user2, order, order2, order3);
        checkAssignment(user1);

        userShiftReassignManager.reassignOrders(Set.of(order.getId(), order2.getId()), Set.of(), Set.of(),
                user1.getId());
        checkAssignment(user1, order, order2);
    }

    @Test
    void testSetLostStatusToLockerOrderAfterCourierCancelTaskWithNotLostStatus() {
        GeoPoint geoPoint = GeoPointGenerator.generateLonLat();

        Order order = getPickupOrder(EXTERNAL_ORDER_ID_1, pickupPointLocker, geoPoint);
        Order order2 = getPickupOrder(EXTERNAL_ORDER_ID_2, pickupPointLocker, geoPoint);

        transactionTemplate.execute(ts -> {
            var us = userShiftRepository.findById(userShift.getId()).orElseThrow();
            userShiftReassignManager.assign(us, order);
            userShiftReassignManager.assign(us, order2);
            return null;

        });

        userShiftCommandService.checkin(userShift.getUser(), new UserShiftCommand.CheckIn(userShift.getId()));
        userShiftCommandService.startShift(userShift.getUser(), new UserShiftCommand.Start(userShift.getId()));
        testUserHelper.finishPickupAtStartOfTheDay(userShift, true);

        LockerDeliveryTask lockerDeliveryTask = reloadTaskWithDependencies();
        RoutePoint routePoint = lockerDeliveryTask.getRoutePoint();

        assertThat(lockerDeliveryTask.getSubtasks()).hasSize(2);

        testUserHelper.finishDelivery(routePoint, OrderDeliveryTaskFailReasonType.COURIER_NEEDS_HELP,
                OrderPaymentType.CASH, false);
        assertThatFailSubtasksAndCancelTask();
        checkAssignment(user, order, order2);

        var failReason = new OrderDeliveryFailReason(
                OrderDeliveryTaskFailReasonType.ORDER_WAS_LOST,
                "comment", null,
                Source.OPERATOR
        );
        transactionTemplate.execute(ts -> {
            orderManager.cancelOrder(order2, failReason);
            return null;
        });

        checkAssignment(user, order);

        userShiftManager.finishTasksAndCloseShift(userShift.getId(), "TEST", Source.SYSTEM);
        userShiftCommandService.finishUserShift(new UserShiftCommand.Finish(userShift.getId()));
        Order o = orderRepository.findById(order2.getId()).orElseThrow();
        assertThat(o.getOrderFlowStatus()).isEqualTo(OrderFlowStatus.LOST);
    }


    private void reopenTaskForOrder(Order order) {
        orderManager.reopenTask(order.getExternalOrderId());

        Order o = orderRepository.findById(order.getId()).orElseThrow();

        LockerDeliveryTask lockerDeliveryTask = reloadTaskWithDependencies();
        assertThat(o.getOrderFlowStatus()).isEqualTo(OrderFlowStatus.TRANSPORTATION_RECIPIENT);

        assertThat(lockerDeliveryTask.getStatus()).isEqualTo(LockerDeliveryTaskStatus.NOT_STARTED);
        assertThat(lockerDeliveryTask.getFailReason()).isNull();
        assertThat(lockerDeliveryTask.getRoutePoint().getStatus().isTerminal()).isFalse();

        List<LockerSubtask> subtasks = lockerDeliveryTask.getSubtasks();
        LockerSubtask lockerSubtask = subtasks.stream()
                .filter(st -> Objects.equals(st.getOrderId(), o.getId()))
                .findFirst()
                .orElseThrow();
        assertThat(lockerSubtask.getStatus()).isEqualTo(LockerDeliverySubtaskStatus.NOT_STARTED);
        assertThat(lockerSubtask.getFailReason()).isNull();
        assertThat(lockerSubtask.getFinishedAt()).isNull();
    }

    private Order getPickupOrder(String externalOrderId, PickupPoint pickupPoint, GeoPoint geoPoint) {
        OrderGenerateService.OrderGenerateParam.OrderGenerateParamBuilder orderGenerateParamBuilder =
                OrderGenerateService.OrderGenerateParam.builder()
                        .externalOrderId(externalOrderId)
                        .deliveryDate(LocalDate.now(clock))
                        .deliveryServiceId(239L)
                        .pickupPoint(pickupPoint)
                        .addressGenerateParam(AddressGenerator.AddressGenerateParam.builder()
                                .geoPoint(geoPoint)
                                .build())
                        .flowStatus(OrderFlowStatus.SORTING_CENTER_PREPARED);

        Order order = orderGenerateService.createOrder(
                orderGenerateParamBuilder
                        .build());


        scManager.createOrders();
        ScOrder scOrder = scOrderRepository.findByYandexIdAndPartnerId(order.getExternalOrderId(),
                        sortingCenter.getId())
                .orElseThrow();
        scManager.updateWhenCreatedOrder(scOrder.getYandexId(), "SC-" + scOrder.getId(), scOrder.getPartnerId());
        scManager.updateOrderStatuses(order.getExternalOrderId(), scOrder.getPartnerId(), List.of(
                new OrderStatusUpdate(OrderStatusType.ORDER_ARRIVED_TO_SO_WAREHOUSE.getCode(),
                        Instant.now(clock).minusSeconds(2 * 60 * 60 * 24)),
                new OrderStatusUpdate(OrderStatusType.ORDER_READY_TO_BE_SEND_TO_SO_FF.getCode(),
                        Instant.now(clock).minusSeconds(2 * 60 * 60 * 24))
        ));
        return order;
    }

    private void assertThatFailSubtasksAndCancelTask() {
        LockerDeliveryTask lockerDeliveryTask = reloadTaskWithDependencies();
        assertThat(lockerDeliveryTask.getStatus()).isEqualTo(LockerDeliveryTaskStatus.CANCELLED);
        List<LockerSubtask> subtasks = lockerDeliveryTask.getSubtasks();
        assertThat(subtasks).extracting(LockerSubtask::getStatus)
                .containsOnly(LockerDeliverySubtaskStatus.FAILED);
    }

    private void checkAssignment(User user, Order... orders) {
        List<Order> currentUserOrders = orderRepository.findCurrentUserOrders(user.getId());
        assertThat(currentUserOrders).containsExactlyInAnyOrder(orders);
    }

    private void createClientReturn() {
        ClientReturnCreateDto clientReturnCreateDto = new ClientReturnCreateDto();
        clientReturnCreateDto.setReturnId(CLIENT_RETURN_EXTERNAL_ID_1);
        clientReturnCreateDto.setBarcode(clientReturnBarcodeExternalCreated1);
        clientReturnCreateDto.setPickupPointId(pickupPointPvz.getId());
        clientReturnCreateDto.setLogisticPointId(pickupPointPvz.getLogisticPointId());
        clientReturnService.create(clientReturnCreateDto);
        clientReturnService.receiveOnPvz(CLIENT_RETURN_EXTERNAL_ID_1);
    }

    private void finishLockerLoadingAndDoNotTakeClientReturn(LockerDeliveryTask task, Order order) {
        RoutePoint routePoint = task.getRoutePoint();
        UserShift userShift = routePoint.getUserShift();
        userShiftCommandService.finishLoadingLocker(user,
                new UserShiftCommand.FinishLoadingLocker(
                        userShift.getId(), routePoint.getId(),
                        task.getId(), null,
                        ScanRequest.builder()
                                .successfullyScannedOrders(List.of(order.getId()))
                                .build()
                )
        );

        userShiftCommandService.finishUnloadingLocker(user,
                new UserShiftCommand.FinishUnloadingLocker(
                        userShift.getId(),
                        routePoint.getId(),
                        task.getId(),
                        Set.of()
                )
        );
    }

    private LockerDeliveryTask reloadTaskWithDependencies() {
        return reloadTaskWithDependencies(userShift);
    }

    private LockerDeliveryTask reloadTaskWithDependencies(UserShift userShift) {
        return transactionTemplate.execute(action -> {
            UserShift us = userShiftRepository.findByIdOrThrow(userShift.getId());
            RoutePoint rp = us.streamDeliveryRoutePoints().findFirst().orElseThrow();
            assertThat(rp).isNotNull();
            rp.getUserShift().getUser();
            LockerDeliveryTask lockerTask = rp.streamLockerDeliveryTasks().findFirst().orElseThrow();
            assertThat(lockerTask).isNotNull();
            lockerTask.getSubtasks().size();
            return lockerTask;
        });
    }
}
