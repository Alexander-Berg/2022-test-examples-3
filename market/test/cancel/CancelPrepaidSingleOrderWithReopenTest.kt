package ru.yandex.market.tpl.courier.test.cancel

import androidx.test.filters.LargeTest
import com.agoda.kakao.screen.Screen
import io.qameta.allure.kotlin.Allure
import io.qameta.allure.kotlin.Description
import io.qameta.allure.kotlin.Epic
import io.qameta.allure.kotlin.Issue
import io.qameta.allure.kotlin.Story
import io.qameta.allure.kotlin.TmsLink
import io.qameta.allure.kotlin.junit4.DisplayName
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import org.junit.Test
import ru.yandex.market.tpl.courier.arch.common.seconds
import ru.yandex.market.tpl.courier.arch.ext.swipeUp
import ru.yandex.market.tpl.courier.arch.ext.testDataRepository
import ru.yandex.market.tpl.courier.arch.ext.wait
import ru.yandex.market.tpl.courier.domain.feature.task.OrderDeliveryTask
import ru.yandex.market.tpl.courier.domain.feature.task.delivery.PaymentType
import ru.yandex.market.tpl.courier.presentation.feature.screen.CancellationReasonsScreen
import ru.yandex.market.tpl.courier.presentation.feature.screen.DrawerNavigationScreen
import ru.yandex.market.tpl.courier.presentation.feature.screen.FinishedTaskListScreen
import ru.yandex.market.tpl.courier.presentation.feature.screen.MainScreen
import ru.yandex.market.tpl.courier.presentation.feature.screen.MultiOrderScreen
import ru.yandex.market.tpl.courier.test.BaseTest

@LargeTest
@Epic("Отмена заказов")
@DisplayName("Отмена заказов")
class CancelPrepaidSingleOrderWithReopenTest: BaseTest() {

    private lateinit var orderId: String
    private lateinit var orderPlace: String

    override fun prepareData() {
        testDataRepository.createShift(uid)
        val routePoint = testDataRepository.createRoutePointWithDeliveryTask(
            uid = uid,
            phone = "+79000000001",
            isPaid = true,
            paymentType = PaymentType.Prepaid
        )
        val routePointId = routePoint.id
        orderId = (routePoint.tasks.first() as OrderDeliveryTask).orderId.unwrap()
        orderPlace = (routePoint.tasks.first() as OrderDeliveryTask).order.places.first().barcode.unwrap()
        testDataRepository.checkIn()
        testDataRepository.manualFinishPickup(uid)
        testDataRepository.manualSwitchRoutePoint(routePointId, uid)
        testDataRepository.arriveAtRoutePoint(routePointId)
    }

    @Test
    @Issue("MARKETTPLAPP-1379")
    @TmsLink("courier-app-242")
    @Story("Отмена заказов")
    @DisplayName("Отмена и восстановление одиночного предоплаченного заказа")
    @Description("Отмена простого предоплаченного заказа по причине 'Клиент отказался от заказа'")
    fun cancelPrepaidSingleOrderWithReopenTest() {
        Screen.onScreen<MainScreen> {
            val drawerOrderItem = viewContainsText(orderId)

            Allure.step("Дождаться появление заказа в дровере") {
                wait until {
                    drawerOrderItem { isVisible() }
                }
            }

            Allure.step("Проскролить дровер до заказа") {
                swipeUp { rootSwipeView } until {
                    drawerOrderItem { isCompletelyDisplayed() }
                }
            }

            Allure.step("Нажать на заказ в дровере") {
                drawerOrderItem { click() }
            }
        }

        Screen.onScreen<MultiOrderScreen> {
            Allure.step("Дождаться появления карточки заказа") {
                wait until {
                    rootSwipeView { isVisible() }
                }
            }

            Allure.step("Проскролить экран до кнопки отмены заказа") {
                swipeUp { rootSwipeView } until {
                    cancelOrderButton { isCompletelyDisplayed() }
                }
            }

            Allure.step("Нажать на кнопку отмены заказа") {
                cancelOrderButton { click() }
            }
        }

        Screen.onScreen<CancellationReasonsScreen> {
            Allure.step("Дождаться появления списка причин отмены") {
                wait until {
                    cancellationReasonList { isDisplayed() }
                }
            }

            cancellationReasonList {
                Allure.step("Выбор причины отмены") {
                    childWith<CancellationReasonsScreen.Item> { withText("Не могу дозвониться") } perform {
                        Allure.step("Проверить наличие причины отмены \"Не могу дозвониться\"") {
                            isDisplayed()
                        }
                    }

                    childWith<CancellationReasonsScreen.Item> { withText("Клиент отказался от заказа") } perform {
                        Allure.step("Проверить наличие причины отмены \"Клиент отказался от заказа\"") {
                            isDisplayed()
                        }
                    }

                    childWith<CancellationReasonsScreen.Item> { withText("Клиент хочет доставку на другой адрес") } perform {
                        Allure.step("Проверить наличие причины отмены \"Клиент хочет доставку на другой адрес\"") {
                            isDisplayed()
                        }
                    }

                    childWith<CancellationReasonsScreen.Item> { withText("Неверные координаты") } perform {
                        Allure.step("Проверить наличие причины отмены \"Неверные координаты\"") {
                            isDisplayed()
                        }
                    }

                    childWith<CancellationReasonsScreen.Item> { withText("Заказ повреждён") } perform {
                        Allure.step("Проверить наличие причины отмены \"Заказ повреждён\"") {
                            isDisplayed()
                        }
                    }


                    childWith<CancellationReasonsScreen.Item> { withText("Клиент отказался от заказа") } perform {
                        Allure.step("Выбрать причину отмены \"Клиент отказался от заказа\"") {
                            click()
                        }
                    }
                }
            }

            Allure.step("Нажать кнопку \"Далее\"") {
                continueButton { click() }
            }

            Allure.step("Дождаться появления кнопки \"Подтвердить\"") {
                wait until {
                    confirmButton { isDisplayed() }
                }
            }

            Allure.step("Проверить отображение посылки") {
                val order = orderContent(orderPlace)

                order { isDisplayed() }

                val reason = orderContent("Клиент отказался от заказа")
                reason { isDisplayed() }
            }

            Allure.step("Нажать кнопку \"Подтвердить\"") {
                confirmButton { click() }
            }

            Allure.step("Дождаться закрытия списка причин отмены") {
                wait until {
                    cancellationReasonList { doesNotExist() }
                }
            }
        }

        Screen.onScreen<MainScreen> {
            Allure.step("Дождаться, когда задание пропадет из bottom sheet'а") {
                wait until {
                    viewContainsText(orderId) perform { doesNotExist() }
                }
            }

            runBlocking { delay(10000) }

            Allure.step("Идем в меню") {
                wait(30.seconds) until {
                    navigationDrawerButton  { isCompletelyDisplayed() }
                }
                navigationDrawerButton { click() }
            }
        }

        Screen.onScreen<DrawerNavigationScreen> {
            Allure.step("Идем в завершенные задания") {
                wait(30.seconds) until {
                    rootSwipeView { isCompletelyDisplayed() }
                }

                finishedTaskListButton { click() }
            }
        }

        Screen.onScreen<FinishedTaskListScreen> {
            Allure.step("Дожидаемся отрисовки экрана и проваливаемся в заказ") {
                wait until {
                    tasksList { isCompletelyDisplayed() }
                }

                val taskView = taskView(orderId)

                wait until {
                    taskView { isCompletelyDisplayed() }
                }

                taskView { click() }
            }
        }

        Screen.onScreen<MultiOrderScreen> {
            Allure.step("Дождаться появления карточки заказа") {
                wait until {
                    rootSwipeView { isVisible() }
                }
            }

            Allure.step("Проскролить экран до кнопки возобновление заказа") {
                swipeUp { rootSwipeView } until {
                    reopenOrderButton { isCompletelyDisplayed() }
                }
            }

            Allure.step("Возобновляем") {
                reopenOrderButton { click() }
            }
        }

        Screen.onScreen<MainScreen> {
            val drawerOrderItem = viewContainsText(orderId)

            Allure.step("Дождаться появление заказа в дровере") {
                wait until {
                    drawerOrderItem { isVisible() }
                }
            }
        }
    }
}