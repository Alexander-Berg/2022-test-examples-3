const contimer = require('contimer');
const {assert} = require('chai');

const Asker = require('../lib/asker');
const httpTest = require('./lib/http');

module.exports = {
    '#getUrl() should returns requested URL built from host, port and path options': function () {
        const PROTOCOL = 'http:';
        const HOST = 'yandex.com';
        const PORT = '443';
        const PATH = '/search';
        const request = new Asker({
            protocol: PROTOCOL,
            host: HOST,
            port: PORT,
            path: PATH,
        });

        assert.strictEqual(request.getUrl(), `${PROTOCOL}//${HOST}:${PORT}${PATH}`,
            'url generated by Asker#getUrl is correct');
    },

    '#done() should call callback if passed to constructor': function (done) {
        const ERROR = new Error('error');
        const RESPONSE = 'ok';

        const request = new Asker({}, function (error, response) {
            assert.strictEqual(error, ERROR,
                'error argument passed to callback');

            assert.strictEqual(response, RESPONSE,
                'error argument passed to callback');

            done();
        });

        request.done(ERROR, RESPONSE);
    },

    '#done() should not trying to call undefined callback': function () {
        const request = new Asker();

        assert.doesNotThrow(function () {
            request.done();
        });
    },

    '#done() should set #_isRunning flag to false': function () {
        const request = new Asker();

        request._isRunning = true;

        assert.strictEqual(request._isRunning, true,
            '_isRunning was set to true manually');

        request.done();

        assert.strictEqual(request._isRunning, false,
            '_isRunning was set to false by #done() call');
    },

    '#getTimers() must returns `undefined` for timers, which is not resolved': function () {
        const timers = (new Asker()).getTimers();

        assert.strictEqual(typeof timers.network, 'undefined', 'network time is undefined');
        assert.strictEqual(typeof timers.total, 'undefined', 'total time is undefined');
    },

    '#getTimers() returns timers values': function () {
        const request = new Asker();
        const DELTA = 100;

        request._networkTime = {time: DELTA};

        assert.strictEqual(request.getTimers().network, DELTA, 'network time is computed right');

        request._executionTime = {time: DELTA};

        assert.strictEqual(request.getTimers().total, DELTA, 'total time is computed right');
    },

    '#getTimers returns `NaN` if timers was not resolved': function () {
        const request = new Asker();

        assert(Number.isNaN(Number(request.getTimers().total)), '#getTimers().total is NaN');
        assert(Number.isNaN(Number(request.getTimers().network)), '#getTimers().network is NaN');
    },

    'request execution starts "execution" timer': function () {
        const request = new Asker();

        request._execute();

        assert(contimer.stop(request._timerCtx, request.buildTimerId('execution')).time >= 0,
            '#execute starts "execution" timer');
    },

    'httpRequest `socket` event listener starts "network" timer': httpTest(function (done, server) {
        const request = new Asker({port: server.port});

        server.addTest(function (req, res) {
            assert.strictEqual(typeof contimer.stop(request._timerCtx, request.buildTimerId('network')).time, 'number',
                'network was started on request start');

            res.end();
            done();
        });

        request._execute();
    }),

    '#getTimers returns undefined `network` while request is not completed': httpTest(function (done, server) {
        const request = new Asker({port: server.port});

        server.addTest(function (req, res) {
            assert.strictEqual(typeof request.getTimers().network, 'undefined',
                'network timer is undefined');

            res.end();

            done();
        });

        request._execute();
    }),

    'httpRequest `end` event listener stops the "network" timer': httpTest(function (done, server) {
        server.addTest(function (req, res) {
            res.end();
        });

        const request = new Asker({port: server.port}, function () {
            assert(request.getTimers().network >= 0, 'network time is greater or equals to 0');

            done();
        });

        request._execute();
    }),

    '#formatTimestamp must return stringified human-readable result of #getTimers': httpTest(function (done, server) {
        const TIMEOUT = 50;

        server.addTest(function (req, res) {
            setTimeout(function () {
                res.end();
            }, TIMEOUT);
        });

        const request = new Asker({port: server.port}, function () {
            const ts = request.formatTimestamp();

            assert.ok(/^in \d+~\d+ ms$/.test(ts), 'timestamp format is ok');

            const netTime = parseInt(/^in (\d+)~/.exec(ts)[1], 10);
            const totalTime = parseInt(/~(\d+) ms$/.exec(ts)[1], 10);

            assert.ok(!Number.isNaN(netTime), 'network time is a number');
            assert.ok(!Number.isNaN(totalTime), 'total time is a number');

            assert.strictEqual(netTime, request.getTimers().network, 'stringified and original net time is equal');
            assert.strictEqual(totalTime, request.getTimers().total, 'stringified and original total time is equal');

            done();
        });

        request._execute();
    }),

    '#formatTimestamp interpolate undefined network time as "0"': function () {
        const request = new Asker();

        assert.ok(/^in 0~/.test(request.formatTimestamp()), 'net time is "0"');
    },

    '#getResponseMetaBase returns fulfilled object after request execution': httpTest(function (done, server) {
        server.addTest(function (req, res) {
            res.end();
        });

        const request = new Asker({port: server.port}, function () {
            const metaBase = request.getResponseMetaBase();

            assert.strictEqual(typeof metaBase, 'object', 'meta is object');
            assert.deepEqual(Object.keys(metaBase), ['time', 'options', 'retries'],
                'meta contains required fields');
            assert.deepEqual(metaBase.time, request.getTimers(),
                'meta.time is equal #getTimers result');
            assert.deepEqual(metaBase.options, request.options,
                'meta.options is equal #options hash');
            assert.strictEqual(metaBase.retries.limit, request.options.maxRetries,
                'meta.retries.limit is equal #options.maxRetries');
            assert.strictEqual(metaBase.retries.used, request.retries,
                'meta.retries.used is equal #retries');

            done();
        });

        request._execute();
    }),
};
