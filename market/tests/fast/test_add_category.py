# coding: utf-8

import pytest
import time
import json
from hamcrest import assert_that
from google.protobuf.timestamp_pb2 import Timestamp

from market.idx.datacamp.controllers.stroller.yatf.test_env import make_stroller
from market.idx.datacamp.proto.category import PartnerCategory_pb2 as DTC
from market.idx.datacamp.yatf.matchers.matchers import HasStatus


@pytest.yield_fixture(scope='module')
def stroller(
    config,
    yt_server,
    log_broker_stuff,
):
    with make_stroller(
        config,
        yt_server,
        log_broker_stuff,
    ) as stroller_env:
        yield stroller_env


def request(stroller, business_id=None, category_id=None, category_name=None, parent_id=None, ts=None):
    category = DTC.PartnerCategory()
    if category_id is not None:
        category.id = category_id
    if parent_id is not None:
        category.parent_id = parent_id
    if category_name is not None or category_id is not None:
        category.name = category_name or 'category {}'.format(category_id)
    if business_id is not None:
        category.business_id = business_id
    if ts is not None:
        category.meta.timestamp.seconds = ts.seconds
    return stroller.post(path='/v1/partner_categories', data=category.SerializeToString())


def test_add_category_base(stroller):
    ts = Timestamp()
    ts.FromJsonString('2020-08-16T17:25:55Z')

    response = request(stroller, business_id=2, category_id=1000, parent_id=123, ts=ts)
    assert_that(response, HasStatus(200))
    assert response.headers['Content-type'] == 'application/json; charset=utf-8'
    expected_data = {
        'id': 1000,
        'parent_id': 123,
        'business_id': 2,
        'name': 'category 1000',
        'meta': {
            'timestamp': {
                'seconds': ts.seconds,
            }
        }
    }
    assert response.json() == expected_data


def HasFreshTimestamp(response):
    # что бы не зависеть от учета таймозон будем проверять, что таймстэмп не старше суток
    return response['meta']['timestamp']['seconds'] > time.time() - 24 * 60 * 60


def test_autogenerated_data(stroller):
    # проверяем генерацию айдишника категории из имени, и добавление таймстэмпа

    response1 = request(stroller, business_id=3, category_name='aaa').json()
    response2 = request(stroller, business_id=3, category_name='aab').json()
    response3 = request(stroller, business_id=4, category_name='aaa').json()

    # айдишники категорий с одинаковым именем совпадают
    assert response1['id'] == response3['id']
    assert response1['id'] != response2['id']
    for response in (response1, response2, response3):
        assert HasFreshTimestamp(response)
        assert response['auto_generated_id']


def test_update_category(stroller):
    old_ts = Timestamp()
    old_ts.FromJsonString('2020-07-16T17:25:55Z')
    response = request(stroller, business_id=5, category_id=100, ts=old_ts)

    assert_that(response, HasStatus(200))
    json_response = response.json()
    assert json_response['meta']['timestamp']['seconds'] == old_ts.seconds
    assert 'auto_generated_id' not in json_response

    # Посылаем категорию с таким же ключом (business_id + category_id), но с новым именем.
    # Должно поставитья текущее время, и обновиться имя
    response = request(stroller, business_id=5, category_id=100, category_name='new category 100')
    assert_that(response, HasStatus(200))
    json_response = response.json()
    assert json_response['name'] == 'new category 100'
    assert HasFreshTimestamp(json_response)

    # Надо проверить, что категория именно обновилась, а не продублировалась.
    # Для этого подойдут поля children метода categories, т.к там используется вектор,
    # и нет никаких проверок на дублирование
    categories = json.loads(stroller.get('/v1/partners/5/categories').data)
    assert categories['rootId']['children'] == ['100']
    assert categories['100']['name'] == 'new category 100'


def check_response_error(response, error_msg):
    assert_that(response, HasStatus(200))
    assert response.json().get('message') == error_msg


def test_bad_params(stroller):
    # Категория без имени
    response = request(stroller, business_id=1)
    check_response_error(response, 'bad-params')

    # Категория без business_id
    response = request(stroller, category_name='abc')
    check_response_error(response, 'bad-params')

    # parent_id == id
    response = request(stroller, business_id=1, category_id=123, parent_id=123, category_name='abc')
    check_response_error(response, 'bad-params')


def test_already_exists(stroller):
    # Важна уникальность тройки business_id + category_id + category_name

    request(stroller, business_id=6, category_id=100500, category_name='Tables')
    # Если для категории указывается явный айдишник, то с новым category_name запись обновится (см test_update_category)
    # Но если новое имя совпадает с текущим, будет ошибка already-exists
    response = request(stroller, business_id=6, category_id=100500, category_name='Tables')
    check_response_error(response, 'already-exists')

    # С другим явным айдишником категория может добавляться
    response = request(stroller, business_id=6, category_id=100501, category_name='Tables')
    check_response_error(response, None)
    # Для другого партнера категория будет успешно добавлена и со старым айдишником
    response = request(stroller, business_id=7, category_id=100500, category_name='Tables')
    check_response_error(response, None)

    # Без category_id айдишник генерится из имени категории
    request(stroller, business_id=6, category_name='Chairs')
    response = request(stroller, business_id=6, category_name='Chairs')
    check_response_error(response, 'already-exists')
