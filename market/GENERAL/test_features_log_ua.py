#!/usr/bin/env python
# -*- coding: utf-8 -*-

import runner  # noqa

from core.types import (
    BlueOffer,
    DeliveryBucket,
    DeliveryOption,
    GLParam,
    GLType,
    MarketSku,
    Model,
    Offer,
    Outlet,
    PickupBucket,
    PickupOption,
    RegionalModel,
    Shop,
)
from core.testcase import TestCase, main
from core.matcher import Absent, NotEmpty, GreaterFloat, Round, NoKey, LessEq
from core.bigb import (
    ModelViewEvent,
    ModelLastSeenEvent,
    CategoryViewEvent,
    CategoryLastSeenEvent,
    VendorViewEvent,
    VendorLastSeenEvent,
    MarketModelViewsCounter,
    MarketModelLastTimeCounter,
    MarketCategoryViewsCounter,
    MarketCategoryLastTimeCounter,
    MarketVendorViewsCounter,
    MarketVendorLastTimeCounter,
)


import os


class T(TestCase):
    @classmethod
    def prepare(cls):
        cls.settings.default_search_experiment_flags += ['market_filter_offers_with_model_without_sku=0']
        cls.emergency_flags.add_flags(send_feature_log_to_unified_agent=1)
        cls.settings.unified_agent_enabled = True

        cls.index.models += [
            Model(title="kiyanka model has_pic", hyperid=1, vendor_id=1348),  # picinfo will be autogenerated
            Model(title="kiyanka model no_pic", no_picture=True, no_add_picture=True, hyperid=2),
        ]

        cls.index.offers += [
            Offer(title='kiyanka offer has_pic', picture="1", waremd5='wgrU12_pd1mqJ6DJm_9nEA', vendor_id=3491),
            Offer(title='kiyanka offer no_pic', no_picture=True, waremd5='ZRK9Q9nKpuAsmQsKgmUtyg'),
        ]

        # test_offer_recommended_by_vendor data
        cls.index.offers += [
            Offer(title='recommended', is_recommended=True, waremd5='EUhIXt-nprRmCEEWR-cysw'),
            Offer(title='nonrecommended', is_recommended=False, waremd5='VpUwTl5gv-d1vJpKS_S0zQ'),
        ]

        # for a promo code support
        cls.index.shops += [
            Shop(fesh=10001, regions=[187], cpa=Shop.CPA_REAL, subsidies=Shop.SUBSIDIES_ON),
        ]
        cls.index.offers += [Offer(title='мяучий оффер', fesh=10001, cpa=Offer.CPA_REAL)]
        cls.index.offers += [Offer(title='не мяучий оффер', fesh=10001, cpa=Offer.CPA_NO)]

        cls.index.offers += [Offer(title='котиковый оффер', price=100, price_old=200)]

        cls.index.shops += [
            Shop(fesh=1, priority_region=213, regions=[213], name='Новые игрушки', cpa=Shop.CPA_REAL),
        ]

        cls.index.offers += [Offer(fesh=1, title='auction', price=100, price_old=200)]

        for i in range(10):
            cls.index.shops += [Shop(fesh=20000 + i, priority_region=213)]
            cls.index.offers += [Offer(title='offerincut', fesh=20000 + i)]

        # test_rgb_param
        cls.index.mskus += [
            MarketSku(sku=10000001, title="kiyanka blue sku", hyperid=100, blue_offers=[BlueOffer()]),
        ]

    def test_num_columns(self):
        """Тест-ограничение на размер записи лога. Правила добавления колонок в лог:
        https://wiki.yandex-team.ru/market/procedures/pakt-o-degradacii/#praviladobavlenijanovyxlogovidobavlenienovyxpolejjvtekushhielogi
        """
        self.report.request_json('place=prime&text=мяучий&show-urls=external')
        self.feature_log.expect_num_columns(num_columns=LessEq(485)).all()

    def test_promo_codes(self):
        self.report.request_json('place=prime&text=мяучий&show-urls=external')
        self.feature_log.expect(promo_code_enabled=1).once()

    def test_discount(self):
        self.report.request_json('place=prime&text=котиковый&show-urls=external')
        self.feature_log.expect(discount=0.5).once()

    def test_offer_has_pic(self):
        self.report.request_json('place=prime&text=kiyanka+offer+has_pic&show-urls=external')

        self.feature_log.expect(has_picture="1", ware_md5="wgrU12_pd1mqJ6DJm_9nEA")

    def test_offer_no_pic(self):
        self.report.request_json('place=prime&text=kiyanka+offer+no_pic&show-urls=external')

        self.feature_log.expect(has_picture=Absent(), ware_md5="ZRK9Q9nKpuAsmQsKgmUtyg")

    def test_model_has_pic(self):
        self.report.request_json('place=prime&text=kiyanka+model+has_pic')

        self.feature_log.expect(has_picture="1", model_id=1)

    def test_model_no_pic(self):
        self.report.request_json('place=prime&text=kiyanka+model+no_pic')

        # It should be Absent() here, but it break test now.
        self.feature_log.expect(has_picture=None, model_id=2)

    def test_offer_recommended_by_vendor(self):
        self.report.request_json('place=prime&text=recommended&show-urls=external')

        self.feature_log.expect(ware_md5='EUhIXt-nprRmCEEWR-cysw', shop_recommended_by_vendor="1")

        self.report.request_json('place=prime&text=nonrecommended&show-urls=external')

        self.feature_log.expect(ware_md5='VpUwTl5gv-d1vJpKS_S0zQ', shop_recommended_by_vendor=Absent())

    def test_vendor_id(self):
        """Проверяем что для оффера и для модели в лог пишется id вендора"""
        self.report.request_json('place=prime&text=kiyanka+has_pic')
        self.feature_log.expect(model_id=1, vendor_id=1348)
        self.feature_log.expect(ware_md5='wgrU12_pd1mqJ6DJm_9nEA', vendor_id=3491)

    def test_auction(self):
        _ = self.report.request_json('place=prime&text=auction&rids=213')
        self.feature_log.expect(auction_multiplier=1, stable_relevance='8070450532247928833', priority=1).once()

    def test_auction_debug(self):
        response = self.report.request_json('place=prime&text=auction&rids=213&debug=da')
        self.feature_log.expect(auction_multiplier=1).once()

        self.assertFragmentIn(response, {"AUCTION_MULTIPLIER": "1"})

    def test_matrixnet_values(self):
        response = self.report.request_json('place=prime&text=auction&rids=213&debug=da')
        self.feature_log.expect(all_matrixnet_values='Default:0.3;Meta:0.3;DefaultAssesor:0.3;').once()

        self.assertFragmentIn(
            response, {"fullFormulaInfo": [{"tag": "Default", "value": "0.3"}, {"tag": "Meta", "value": "0.3"}]}
        )

    @classmethod
    def prepare_test_reqid_data(cls):
        cls.index.shops += [
            Shop(fesh=101, pickup_buckets=[5001]),
        ]
        cls.index.offers += [
            Offer(hyperid=3, fesh=101),
        ]
        cls.index.outlets += [
            Outlet(fesh=101, point_id=1),
        ]

        cls.index.pickup_buckets += [
            PickupBucket(
                bucket_id=5001,
                fesh=101,
                carriers=[99],
                options=[PickupOption(outlet_id=1)],
                delivery_program=DeliveryBucket.REGULAR_PROGRAM,
            ),
        ]

    def test_reqid(self):
        '''
        Test reqid in feature.log
        '''
        for reqid, place in enumerate(['prime'], start=1):
            self.report.request_json('place={}&hyperid=3&reqid={}'.format(place, reqid))
            self.feature_log.expect(req_id=reqid)
        for reqid, place in enumerate(['geo', 'productoffers', 'defaultoffer'], start=reqid + 1):
            self.report.request_json('place={}&hyperid=3&show-urls=external&reqid={}'.format(place, reqid))
            self.feature_log.expect(req_id=reqid)

        # check single entry for several urls in offer
        reqid += 1
        self.report.request_json('place=geo&hyperid=3&show-urls=cpa,encrypted,external&reqid={}'.format(reqid))
        self.feature_log.expect(req_id=reqid).once()

    def test_x_yandex_icookie(self):
        """
        Проверяем, что зашифрованное значение icookie, попадает в фича-лог в расшифрованном виде
        BCEmkyAbCsICEPzTQsKKZiwaEphOTfJYcplJsb6WeCNz9ThbLjUw5pw1K8G40cyJPs%2BVrWxAzPzzs34zCBQWvGkphV4%3D => 6774478491508471626
        """
        self.report.request_json('place=prime&text=kiyanka&x-yandex-icookie=6774478491508471626')
        self.feature_log.expect(icookie='6774478491508471626')

    @classmethod
    def prepare_cpc(cls):
        cls.index.shops += [
            Shop(fesh=201, cpa=Shop.CPA_NO, cpc=Shop.CPC_REAL),
            Shop(fesh=202, cpa=Shop.CPA_REAL, cpc=Shop.CPC_NO),
        ]
        cls.index.offers += [
            Offer(hyperid=1201, fesh=201),  # cpc offer - offer with url from cpc shop
            Offer(hyperid=1202, fesh=202, cpa=Offer.CPA_REAL),  # non-cpc - offer with url from non-cpc shop
            Offer(
                hyperid=1203, fesh=201, cpa=Offer.CPA_REAL, has_url=False
            ),  # non-cpc - offer without url from cpc shop
        ]

    def test_cpc(self):
        """
        Проверяем запись признака CPC оффера
        """

        # cpc offer - offer with url from cpc shop
        response = self.report.request_json('place=productoffers&show-urls=external,cpa&hyperid=1201')
        self.feature_log.expect(model_id=1201, cpc=1).times(1)

        # non-cpc - offer with url from non-cpc shop
        response = self.report.request_json('place=productoffers&show-urls=external,cpa&hyperid=1202&debug=da')
        self.assertFragmentIn(
            response,
            {'entity': 'offer', 'urls': {'direct': NotEmpty(), 'cpa': NotEmpty(), 'encrypted': NoKey('encrypted')}},
        )
        self.feature_log.expect(model_id=1202, cpa1=1).times(1)

        # non-cpc - offer without url from cpc shop
        response = self.report.request_json('place=productoffers&show-urls=external,cpa&hyperid=1203&debug=da')
        self.assertFragmentIn(response, {'brief': {'filters': {'HIDE_CPC_OFFER_WAS_DOWNGRADED': 1}}})

    @classmethod
    def prepare_offer_relative_price(cls):
        cls.index.shops += [
            Shop(fesh=501, priority_region=1),
            Shop(fesh=502, priority_region=1),
            Shop(fesh=503, priority_region=2),
        ]
        cls.index.offers += [
            Offer(
                hyperid=1501,
                fesh=501,
                price=3000,
                delivery_options=[
                    DeliveryOption(price=3000),
                ],
            ),
            Offer(hyperid=1501, fesh=502, price=12000, has_delivery_options=False),
            Offer(hyperid=1501, fesh=503, price=12000),
        ]
        cls.index.regional_models += [
            RegionalModel(hyperid=1501, rids=[1], price_min=1000, price_med=2000, price_max=6000),
        ]

    def test_offer_relative_price(self):
        """
        Проверяем запись относительной цены оффера
        """
        _ = self.report.request_json('place=productoffers&show-urls=external,cpa&hyperid=1501&rids=1')
        # Overall median calculated by offers is 12000
        self.feature_log.expect(
            model_id=1501,
            shop_id=501,
            other={
                # ... без учёта доставки
                'min_rel': 3,
                'avg_rel': 1.5,
                'max_rel': 0.5,
                'offer_price_div_overall_median_model_price': 0.25,
                # ... с учётом доставки
                'no_default_delivery_option': Absent(),
                'min_rel_with_delivery': 6,
                'avg_rel_with_delivery': 3,
                'max_rel_with_delivery': 1,
                'offer_price_div_overall_median_model_price_with_delivery': 0.5,
            },
        )

    def test_offer_no_default_delivery_option(self):
        """
        Проверяем запись признака отсутсвия дефолтной доставки
        """
        _ = self.report.request_json('place=productoffers&show-urls=external,cpa&hyperid=1501')
        self.feature_log.expect(
            model_id=1501,
            shop_id=502,
            other={
                'no_default_delivery_option': 1,
            },
        )

    @classmethod
    def prepare_uniq_color_factors(cls):
        """Создаем три модели:
        - в одной все офферы имеют уникальный цвет
        - во второй только один из 4-х офферов с уникальным цветом
        - в третьей нет офферов с уникальным цветом
        """
        cls.index.gltypes += [
            GLType(
                param_id=160900101,
                hid=1609001,
                gltype=GLType.ENUM,
                subtype='image_picker',
                cluster_filter=True,
                hidden=True,
                values=[1, 2, 3],
            ),
            GLType(
                param_id=160900102,
                hid=1609001,
                gltype=GLType.ENUM,
                subtype='color',
                cluster_filter=True,
                has_model_filter_index=False,
                values=[1, 2, 3],
            ),
        ]

        cls.index.models += [
            Model(hyperid=1609011, hid=1609001),
            Model(hyperid=1609012, hid=1609001),
            Model(hyperid=1609013, hid=1609001),
            Model(hyperid=1609014, hid=1609001),
            Model(hyperid=1609015, hid=1609001),
        ]

        cls.index.offers += [
            Offer(
                hyperid=1609011,
                fesh=1609021,
                glparams=[
                    GLParam(param_id=160900101, value=1),
                    GLParam(param_id=160900102, value=1),
                ],
            ),
            Offer(
                hyperid=1609011,
                fesh=1609022,
                glparams=[
                    GLParam(param_id=160900101, value=2),
                    GLParam(param_id=160900102, value=2),
                ],
            ),
            Offer(
                hyperid=1609011,
                fesh=1609023,
                glparams=[
                    GLParam(param_id=160900101, value=3),
                ],
            ),
            Offer(
                hyperid=1609011,
                fesh=1609024,
                glparams=[
                    GLParam(param_id=160900101, value=3),
                ],
            ),
            Offer(
                hyperid=1609012,
                fesh=1609021,
                glparams=[
                    GLParam(param_id=160900101, value=1),
                    GLParam(param_id=160900102, value=1),
                ],
            ),
            Offer(
                hyperid=1609012,
                fesh=1609022,
                glparams=[
                    GLParam(param_id=160900102, value=2),
                ],
            ),
            Offer(
                hyperid=1609012,
                fesh=1609023,
                glparams=[
                    GLParam(param_id=160900102, value=3),
                ],
            ),
            Offer(
                hyperid=1609012,
                fesh=1609022,
                glparams=[
                    GLParam(param_id=160900102, value=3),
                ],
            ),
            Offer(hyperid=1609013, fesh=1609021, glparams=[]),
            Offer(hyperid=1609013, fesh=1609022, glparams=[]),
            Offer(hyperid=1609013, fesh=1609023, glparams=[]),
            Offer(
                hyperid=1609014,
                fesh=1609021,
                glparams=[
                    GLParam(param_id=160900101, value=1),
                ],
            ),
            Offer(hyperid=1609014, fesh=1609022, glparams=[]),
            Offer(hyperid=1609014, fesh=1609023, glparams=[]),
            Offer(hyperid=1609014, fesh=1609023, glparams=[]),
            Offer(
                hyperid=1609015,
                fesh=1609021,
                glparams=[
                    GLParam(param_id=160900102, value=1),
                ],
                randx=4,
            ),
            Offer(hyperid=1609015, fesh=1609022, glparams=[], randx=3),
            Offer(hyperid=1609015, fesh=1609023, glparams=[], randx=2),
            Offer(hyperid=1609015, fesh=1609023, glparams=[], randx=1),
        ]

    def test_uniq_color_factors(self):
        """Проверяем запись фактора наличия уникального цвета и
        фактора доли офферов с уникальным цветом
        """

        # модель со всеми офферами с уникальным цветом (glfilters и hid для определенности ДО)
        self.report.request_json(
            'place=productoffers&glfilter=160900101:1&hid=1609001&offers-set=default&show-urls=external,cpa&hyperid=1609011'
        )
        self.feature_log.expect(model_id=1609011, offer_has_uniq_color=1, uniq_color_pcnt=1)

        # модель с одним оффером с уникальным цветом (glfilters и hid для определенности ДО)
        self.report.request_json(
            'place=productoffers&glfilter=160900101:1&hid=1609001&offers-set=default&show-urls=external,cpa&hyperid=1609012'
        )
        self.feature_log.expect(model_id=1609012, offer_has_uniq_color=1, uniq_color_pcnt=0.25)

        # модель без уникальных и базовых цветов
        self.report.request_json('place=productoffers&offers-set=default&show-urls=external,cpa&hyperid=1609013')
        self.feature_log.expect(model_id=1609013, offer_has_uniq_color=Absent(), uniq_color_pcnt=Absent())

        # модель с одним оффером с уникальным цветом без базовых цветов
        # (glfilters и hid для определенности ДО)
        self.report.request_json(
            'place=productoffers&glfilter=160900101:1&hid=1609001&offers-set=default&show-urls=external,cpa&hyperid=1609014'
        )
        self.feature_log.expect(model_id=1609014, offer_has_uniq_color=1, uniq_color_pcnt=0.25)

        # модель с одним оффером с базовым цветом без уникальных цветов
        self.report.request_json(
            'place=productoffers&hid=1609001&offers-set=default&show-urls=external,cpa&hyperid=1609015'
        )
        self.feature_log.expect(model_id=1609015, offer_has_uniq_color=Absent(), uniq_color_pcnt=Absent())

    def test_base_color_factors(self):
        """Проверяем запись фактора наличия уникального цвета и
        фактора доли офферов с уникальным цветом
        """

        # модель со двумя офферами с базовым цветом (glfilters и hid для определенности ДО)
        self.report.request_json(
            'place=productoffers&glfilter=160900101:1&hid=1609001&offers-set=default&show-urls=external,cpa&hyperid=1609011'
        )
        self.feature_log.expect(model_id=1609011, offer_has_base_color=1, base_color_pcnt=0.5)

        # модель со всем офферами с базовым цветом (glfilters и hid для определенности ДО)
        self.report.request_json(
            'place=productoffers&glfilter=160900101:1&hid=1609001&offers-set=default&show-urls=external,cpa&hyperid=1609012'
        )
        self.feature_log.expect(model_id=1609012, offer_has_base_color=1, base_color_pcnt=1)

        # модель без уникальных цветов
        self.report.request_json('place=productoffers&offers-set=default&show-urls=external,cpa&hyperid=1609013')
        self.feature_log.expect(model_id=1609013, offer_has_base_color=Absent(), base_color_pcnt=Absent())

        # модель с одним оффером с уникальным цветом без базовых цветов
        # (glfilters и hid для определенности ДО)
        self.report.request_json(
            'place=productoffers&glfilter=160900101:1&hid=1609001&offers-set=default&show-urls=external,cpa&hyperid=1609014'
        )
        self.feature_log.expect(model_id=1609014, offer_has_base_color=Absent(), base_color_pcnt=Absent())

        # модель с одним оффером с базовым цветом без уникальных цветов
        self.report.request_json(
            'place=productoffers&hid=1609001&offers-set=default&show-urls=external,cpa&hyperid=1609015'
        )
        self.feature_log.expect(model_id=1609015, offer_has_base_color=1, base_color_pcnt=0.25)

    def test_log_disabled_during_lockdown(self):
        """
        Проверяем, что ничего не пишется в feature.log во время локдауна.
        """

        def get_log_sizes():
            log_path = os.path.join(self.meta_paths.logs, 'feature.log')
            self.assertFragmentIn(self.report.request_xml('admin_action=flushlogs'), '<status>Logs flushed ok</status>')
            size_before = os.path.getsize(log_path)
            self.report.request_json('place=prime&text=мяучий&show-urls=external')
            self.assertFragmentIn(self.report.request_xml('admin_action=flushlogs'), '<status>Logs flushed ok</status>')
            size_after = os.path.getsize(log_path)
            return size_before, size_after

        self.report.request_plain('place=report_status&report-lockdown=1')
        size_before, size_after = get_log_sizes()
        self.assertEqual(size_after, size_before)

        self.report.request_plain('place=report_status&report-lockdown=0')
        size_before, size_after = get_log_sizes()
        self.assertGreater(size_after, size_before)

    def test_content_api_client(self):
        """Проверяем, что в feature.log пишутся Api факторы только для мобильного приложения (&content-api-client=101)
        и для синего приложения (&content-api-client=14252 в проде и 6713 в тестинге)
        https://st.yandex-team.ru/MARKETOUT-21451
        """
        self.report.request_json('place=prime&text=kiyanka&reqid=100&pp=1001&api=content' '&content-api-client=101')
        self.feature_log.expect(req_id=100)

        self.report.request_json(
            'place=prime&text=kiyanka&reqid=101&pp=1001&api=content'
            '&content-api-client=14252&disable-testing-features=1'
        )
        self.feature_log.expect(req_id=101)

        self.report.request_json(
            'place=prime&text=kiyanka&reqid=101&pp=1001&api=content'
            '&content-api-client=6713&disable-testing-features=0'
        )
        self.feature_log.expect(req_id=101)

        self.report.request_json('place=prime&text=kiyanka&reqid=102&pp=1001&api=content' '&content-api-client=123')
        self.feature_log.expect(req_id=102).never()

        self.report.request_json(
            'place=prime&text=kiyanka&reqid=103&pp=1001&api=content'
            '&content-api-client=0bd9ed4c-aa73-494c-ac2f-335f9c85807e'
        )
        self.feature_log.expect(req_id=103).never()

        self.report.request_json(
            'place=prime&text=kiyanka&reqid=104&pp=1001&api=content' '&content-api-client=bullshit'
        )
        self.feature_log.expect(req_id=104).never()

    def test_api_and_sovetnik_factor_extractor(self):
        response = self.report.request_json(
            'place=prime&text=kiyanka&debug=da&reqid=100&pp=1001&api=content' '&content-api-client=101'
        )
        self.assertFragmentIn(
            response,
            {
                "factors": {
                    "IS_APP": "1",
                }
            },
        )

        response = self.report.request_json(
            'place=prime&text=kiyanka&debug=da&reqid=100&pp=1001&api=content' '&client=sovetnik'
        )
        self.assertFragmentIn(
            response,
            {
                "factors": {
                    "IS_SOVETNIK": "1",
                }
            },
        )

    def test_category_factors(self):
        """Проверяем, что категорийные факторы пишутся в feature.log
        под флагом market_write_category_redirect_features
        https://st.yandex-team.ru/MARKETOUT-21597
        """
        # Prime
        self.report.request_json(
            'place=prime&text=kiyanka&reqid=200&rearr-factors=market_write_category_redirect_features=20'
        )
        self.feature_log.expect(req_id=200, document_type=7)

        self.report.request_json('place=prime&text=kiyanka&reqid=201')
        self.feature_log.expect(req_id=201, document_type=7).never()

        # Parallel
        self.report.request_bs(
            'place=parallel&text=kiyanka&reqid=202&rearr-factors=market_categ_wiz_with_redirect_formula=1;'
            'market_write_category_redirect_features=20'
        )
        self.feature_log.expect(req_id=202, document_type=7)

        self.report.request_bs(
            'place=parallel&text=kiyanka&reqid=203&rearr-factors=market_categ_wiz_with_redirect_formula=1'
        )
        self.feature_log.expect(req_id=203, document_type=7).never()

    def test_parallel_offers_incut_features(self):
        """Проверяем, что на параллельном факторы офферов врезки пишутся в лог только на 10% запросов
        https://st.yandex-team.ru/MARKETOUT-21659
        https://st.yandex-team.ru/MARKETOUT-37376
        https://st.yandex-team.ru/MARKETOUT-39058
        """
        # В лог пишутся факторы офферов на каждый market_parallel_feature_log_rate запрос
        # Значение 0 отключает логирование
        offers_count = 9
        for req_id in range(10):
            self.report.request_bs(
                'place=parallel&text=offerincut&rids=213'
                '&rearr-factors=market_parallel_feature_log_rate=0;market_offers_wizard_incut_url_type=External'
                '&reqid=300'
            )
        self.feature_log.expect(req_id=300, document_type=1).times(0)

        # Под флагом market_parallel_feature_log_rate=1 в лог пишутся факторы офферов всех запросов
        for req_id in range(301, 311):
            self.report.request_bs(
                'place=parallel&text=offerincut&rids=213'
                '&rearr-factors=market_parallel_feature_log_rate=1;market_offers_wizard_incut_url_type=External'
                '&reqid={}'.format(req_id)
            )
            self.feature_log.expect(req_id=req_id, document_type=1).times(offers_count)

    def test_rgb_param(self):
        """Проверяем, что параметр rgb в логах всегда пишется как GREEN
        https://st.yandex-team.ru/MARKETOUT-21897
        """
        # Параметр rgb не задан
        self.report.request_json('place=prime&text=kiyanka+offer&reqid=400')
        self.feature_log.expect(req_id=400, rgb='GREEN')

        # Параметр rgb=green
        self.report.request_json('place=prime&text=kiyanka+offer&reqid=401&rgb=green')
        self.feature_log.expect(req_id=401, rgb='GREEN')

        # Параметр rgb=blue
        self.report.request_json('place=prime&text=kiyanka+blue+sku&reqid=402&rgb=blue')
        self.feature_log.expect(req_id=402, rgb='GREEN')

    @classmethod
    def prepare_personal_features(cls):
        cls.index.models += [
            Model(hyperid=1701, vendor_id=1, hid=170, title="test_thing"),
        ]
        cls.index.offers += [
            Offer(hyperid=1701, fesh=1, vendor_id=1, title="test_thing test_offer"),
        ]

        counters = [
            MarketModelViewsCounter(
                model_view_events=[
                    ModelViewEvent(model_id=1701, view_count=2),
                    ModelViewEvent(model_id=11111, view_count=2),
                ]
            ),
            MarketModelLastTimeCounter(
                model_view_events=[
                    ModelLastSeenEvent(model_id=1701, timestamp=1543322503),
                ]
            ),
            MarketCategoryViewsCounter(
                category_view_events=[
                    CategoryViewEvent(category_id=170, view_count=2),
                    CategoryViewEvent(category_id=11111, view_count=2),
                ]
            ),
            MarketCategoryLastTimeCounter(
                category_view_events=[
                    CategoryLastSeenEvent(category_id=170, timestamp=1543322503),
                ]
            ),
            MarketVendorViewsCounter(
                vendor_view_events=[
                    VendorViewEvent(vendor_id=1, view_count=2),
                    VendorViewEvent(vendor_id=11111, view_count=2),
                ]
            ),
            MarketVendorLastTimeCounter(
                vendor_view_events=[
                    VendorLastSeenEvent(vendor_id=1, timestamp=1543322503),
                ]
            ),
        ]
        cls.bigb.on_request(yandexuid=1001, client='merch-machine').respond(counters=counters)

    def test_personal_features(self):
        """Проверяем, что песональные фичи пишутся в лог"""
        for query in ['&hid=170', '&text=test_thing']:
            response = self.report.request_json('place=prime&yandexuid=1001{}'.format(query))
            self.assertFragmentIn(
                response,
                {
                    'search': {
                        'total': 2,
                        'results': [
                            {'entity': 'product', 'id': 1701},
                            {'entity': 'offer', 'model': {'id': 1701}},
                        ],
                    }
                },
                allow_different_len=False,
            )
        self.feature_log.expect(
            user_model_history_length=2,
            user_category_history_length=2,
            user_vendor_history_length=2,
            user_period_model_unseen=GreaterFloat(0),
            user_period_category_unseen=GreaterFloat(0),
            user_period_vendor_unseen=GreaterFloat(0),
            user_count_model_view=2,
            user_count_category_view=2,
            user_count_vendor_view=2,
            user_ratio_model_view=Round(0.5, 1),
            user_ratio_category_view=Round(0.5, 1),
            user_ratio_vendor_view=Round(0.5, 1),
        ).times(4)

    def test_user_uids_in_feature_log(self):
        """Проверяем что в лог записываются yandex_uid и uuid и passport_uid"""
        response = self.report.request_json(
            'place=prime&text=test_thing' '&yandexuid=1001&puid=186530&uuid=c688a87e4fcc40c181cf677038166ddf'
        )
        self.assertFragmentIn(response, {'search': {'total': 2}})

        self.feature_log.expect(yandex_uid=1001, passport_uid=186530, uuid='c688a87e4fcc40c181cf677038166ddf').times(2)

    @classmethod
    def prepare_shop_logo_features(cls):
        cls.index.shops += [
            Shop(
                fesh=73731,
                shop_logo_retina_url='http://avatars.mdst.yandex.net:80/get-market-shop-logo/1395289/2a00000166aa90931a90f16f243ed902eddc/orig',
                shop_logo_info='28:28:PNG',
                shop_logo_url='http://avatars.mdst.yandex.net:80/get-market-shop-logo/1395289/2a00000166aa90931a90f16f243ed902eddc/small',
            ),
            Shop(
                fesh=73732,
                shop_logo_url='http://avatars.mdst.yandex.net:80/get-market-shop-logo/1395289/2a00000166aa90931a90f16f243ed902eddc/small',
                shop_logo_info='29:29:PNG',
            ),
            Shop(
                fesh=73733,
            ),
        ]

        cls.index.offers += [
            Offer(fesh=73731, price=500, hyperid=88899911),
            Offer(fesh=73732, price=400, hyperid=88899912),
            Offer(fesh=73733, price=100, hyperid=88899913),
        ]

    def test_shop_logo_features_icon(self):
        _ = self.report.request_json('place=productoffers&hyperid=88899911')
        self.feature_log.expect(has_shop_icon=1, has_shop_logo=Absent())

    def test_shop_logo_features_logo(self):
        _ = self.report.request_json('place=productoffers&hyperid=88899912')
        self.feature_log.expect(has_shop_icon=Absent(), has_shop_logo=1)

    def test_shop_logo_features_nothing(self):
        _ = self.report.request_json('place=productoffers&hyperid=88899913')
        self.feature_log.expect(has_shop_icon=Absent(), has_shop_logo=Absent())

    def test_x_market_req_id(self):
        headers = {'X-Market-Req-ID': "x_market_req_id"}
        _ = self.report.request_json('place=prime&text=test_thing&reqid=123')
        self.feature_log.expect(x_market_req_id="")

        _ = self.report.request_json('place=prime&text=test_thing&reqid=123', headers=headers)
        self.feature_log.expect(x_market_req_id="x_market_req_id")

        _ = self.report.request_json('place=productoffers&hyperid=88899912', headers=headers)
        self.feature_log.expect(x_market_req_id="x_market_req_id")

    @classmethod
    def prepare_doc_url_title(cls):
        cls.index.offers += [
            Offer(hid=100, title="search caption.without.mdl", url="offer.without.model"),
            Offer(hid=100, title="search caption.with.collapsed.mdl", hyperid=1000, url="offer.with.collapsed.model"),
            Offer(hid=100, title="caption.with.uncollapsed.mdl", hyperid=1001, url="offer.with.uncollapsed.model"),
        ]
        cls.index.models += [
            Model(hid=100, title="caption.collapsed.mdl", hyperid=1000),  # collapsed model
            Model(hid=100, title="search caption.not.collapsed.mdl", hyperid=1001),  # not collapsed model
        ]

    def test_doc_url_title__with_collapsing(self):
        """
        Проверка полей url и title
        У оффера должен быть урл и тайтл оффера
        У схлопнутой модели должен быть урл и тайтл модели
        У несхлопнутой модели должен быть урл и тайтл модели
        """
        self.report.request_json('place=prime&hid=100&allow-collapsing=1&text=search')
        self.feature_log.expect(model_id="-1", url="offer.without.model", title="search caption.without.mdl")
        self.feature_log.expect(
            offer_collapsed="1", model_id="1000", url="market.yandex.ru/product/1000", title="caption.collapsed.mdl"
        )
        self.feature_log.expect(
            offer_collapsed=None,
            model_id="1001",
            url="market.yandex.ru/product/1001",
            title="search caption.not.collapsed.mdl",
        )

    def test_doc_url_title__without_collapsing(self):
        """
        При allow_collapsing=0 у каждого документа ожидаем урл и тайтл этого документа
        """
        self.report.request_json('place=prime&hid=100&allow-collapsing=0')
        self.feature_log.expect(
            offer_collapsed="0", model_id="-1", url="offer.without.model", title="search caption.without.mdl"
        )
        self.feature_log.expect(
            offer_collapsed="0",
            model_id="1000",
            url="offer.with.collapsed.model",
            title="search caption.with.collapsed.mdl",
        )
        self.feature_log.expect(
            offer_collapsed="0",
            model_id="1001",
            url="offer.with.uncollapsed.model",
            title="caption.with.uncollapsed.mdl",
        )
        self.feature_log.expect(
            offer_collapsed=None, model_id="1000", url="market.yandex.ru/product/1000", title="caption.collapsed.mdl"
        )
        self.feature_log.expect(
            offer_collapsed=None,
            model_id="1001",
            url="market.yandex.ru/product/1001",
            title="search caption.not.collapsed.mdl",
        )


if __name__ == '__main__':
    main()
